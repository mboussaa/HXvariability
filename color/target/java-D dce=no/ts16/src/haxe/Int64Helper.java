// Generated by Haxe 3.3.0
package haxe;

import haxe.root.*;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class Int64Helper extends haxe.lang.HxObject
{
	public Int64Helper(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public Int64Helper()
	{
		//line 31 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		haxe.Int64Helper.__hx_ctor_haxe_Int64Helper(this);
	}
	
	
	public static void __hx_ctor_haxe_Int64Helper(haxe.Int64Helper __temp_me19)
	{
	}
	
	
	public static long parseString(java.lang.String sParam)
	{
		//line 36 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		long base = ((long) (10) );
		//line 37 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		long current = ((long) (0) );
		//line 38 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		long multiplier = ((long) (1) );
		//line 39 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		boolean sIsNegative = false;
		//line 41 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		java.lang.String s = sParam.trim();
		//line 42 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		if (haxe.lang.Runtime.valEq(haxe.lang.StringExt.charAt(s, 0), "-")) 
		{
			//line 43 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			sIsNegative = true;
			//line 44 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			s = haxe.lang.StringExt.substring(s, 1, s.length());
		}
		
		//line 46 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		int len = s.length();
		//line 48 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		{
			//line 48 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			int _g1 = 0;
			//line 48 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			while (( _g1 < len ))
			{
				//line 48 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
				int i = _g1++;
				//line 49 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
				int digitInt = ( ((int) (haxe.lang.Runtime.toInt(haxe.lang.StringExt.charCodeAt(s, ( ( len - 1 ) - i )))) ) - ((int) (48) ) );
				//line 51 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
				if (( ( digitInt < 0 ) || ( digitInt > 9 ) )) 
				{
					//line 52 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
					throw haxe.lang.HaxeException.wrap("NumberFormatError");
				}
				
				//line 55 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
				long digit = ((long) (digitInt) );
				//line 56 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
				if (sIsNegative) 
				{
					//line 57 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
					current = ((long) (( ((long) (current) ) - ((long) (( ((long) (multiplier) ) * ((long) (digit) ) )) ) )) );
					//line 58 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
					if ( ! ((((boolean) (( ((long) (current) ) < 0 )) ))) ) 
					{
						//line 59 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
						throw haxe.lang.HaxeException.wrap("NumberFormatError: Underflow");
					}
					
				}
				else
				{
					//line 62 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
					current = ((long) (( ((long) (current) ) + ((long) (( ((long) (multiplier) ) * ((long) (digit) ) )) ) )) );
					//line 63 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
					if (((boolean) (( ((long) (current) ) < 0 )) )) 
					{
						//line 64 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
						throw haxe.lang.HaxeException.wrap("NumberFormatError: Overflow");
					}
					
				}
				
				//line 67 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
				multiplier = ((long) (( ((long) (multiplier) ) * ((long) (base) ) )) );
			}
			
		}
		
		//line 69 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		return current;
	}
	
	
	public static long fromFloat(double f)
	{
		//line 76 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		if (( java.lang.Double.isNaN(f) ||  ! (haxe.lang.Runtime.isFinite(f))  )) 
		{
			//line 77 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			throw haxe.lang.HaxeException.wrap("Number is NaN or Infinite");
		}
		
		//line 80 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		double noFractions = ( f - ( f % 1 ) );
		//line 83 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		if (( noFractions > 9007199254740991.0 )) 
		{
			//line 84 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			throw haxe.lang.HaxeException.wrap("Conversion overflow");
		}
		
		//line 86 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		if (( noFractions < -9007199254740991.0 )) 
		{
			//line 87 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			throw haxe.lang.HaxeException.wrap("Conversion underflow");
		}
		
		//line 90 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		long result = ((long) (0) );
		//line 91 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		boolean neg = ( noFractions < 0 );
		//line 92 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		double rest = ( (neg) ? ( - (noFractions) ) : (noFractions) );
		//line 94 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		int i = 0;
		//line 95 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		while (( rest >= 1 ))
		{
			//line 96 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			double curr = ( rest % 2 );
			//line 97 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			rest /= ((double) (2) );
			//line 98 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			if (( curr >= 1 )) 
			{
				//line 99 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
				result = ((long) (( ((long) (result) ) + (((long) (( ((long) (1) ) << i )) )) )) );
			}
			
			//line 101 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			 ++ i;
		}
		
		//line 104 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		if (neg) 
		{
			//line 105 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
			result = haxe._Int64.Int64_Impl_.neg(result);
		}
		
		//line 107 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		return result;
	}
	
	
	public static java.lang.Object __hx_createEmpty()
	{
		//line 31 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		return new haxe.Int64Helper(haxe.lang.EmptyObject.EMPTY);
	}
	
	
	public static java.lang.Object __hx_create(haxe.root.Array arr)
	{
		//line 31 "/usr/lib/haxe/std/haxe/Int64Helper.hx"
		return new haxe.Int64Helper();
	}
	
	
}


