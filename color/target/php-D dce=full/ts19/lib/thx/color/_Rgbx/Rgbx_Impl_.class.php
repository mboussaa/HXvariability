<?php

// Generated by Haxe 3.3.0
class thx_color__Rgbx_Rgbx_Impl_ {
	public function __construct(){}
	static function toLab($this1) {
		$tmp = thx_color__Rgbx_Rgbx_Impl_::toXyz($this1);
		return thx_color__Xyz_Xyz_Impl_::toLab($tmp);
	}
	static function toLCh($this1) {
		$tmp = thx_color__Rgbx_Rgbx_Impl_::toLab($this1);
		return thx_color__Lab_Lab_Impl_::toLCh($tmp);
	}
	static function toCmy($this1) {
		return (new _hx_array(array(1 - $this1[0], 1 - $this1[1], 1 - $this1[2])));
	}
	static function toCmyk($this1) {
		$c = 0.0;
		$y = 0.0;
		$m = 0.0;
		$k = null;
		if(_hx_equal($this1->a[0] + $this1[1] + $this1[2], 0)) {
			$k = 1.0;
		} else {
			$tmp = Math::max($this1[0], $this1[1]);
			$tmp1 = Math::max($tmp, $this1[2]);
			$k = 1 - $tmp1;
			$c = (1 - $this1[0] - $k) / (1 - $k);
			$m = (1 - $this1[1] - $k) / (1 - $k);
			$y = (1 - $this1[2] - $k) / (1 - $k);
		}
		return (new _hx_array(array($c, $m, $y, $k)));
	}
	static function toCubeHelixWithGamma($this1, $gamma) {
		$l = (-0.655763666799999867 * $this1[2] + -1.7884503806 * $this1[0] - 3.5172982438 * $this1[1]) / -5.9615122912;
		$bl = $this1->a[2] - $l;
		$k = (1.97294 * ($this1->a[1] - $l) - -0.29227 * $bl) / -0.90649;
		$lgamma = Math::pow($l, $gamma);
		$s = null;
		try {
			$tmp = Math::sqrt($k * $k + $bl * $bl);
			$s = $tmp / (1.97294 * $lgamma * (1 - $lgamma));
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{
				$s = 0.0;
			}
		}
		$h = null;
		try {
			if(!_hx_equal($s, 0)) {
				$tmp1 = Math::atan2($k, $bl);
				$h = $tmp1 / Math::$PI * 180 - 120;
			} else {
				$h = Math::$NaN;
			}
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e1 = $_ex_;
			{
				$h = 0.0;
			}
		}
		$tmp2 = Math::isNaN($s);
		if($tmp2) {
			$s = 0;
		}
		$tmp3 = Math::isNaN($h);
		if($tmp3) {
			$h = 0;
		}
		$tmp4 = $h < 0;
		if($tmp4) {
			$h += 360;
		}
		return (new _hx_array(array($h, $s, $l, 1)));
	}
	static function toGrey($this1) {
		return $this1->a[0] * .2126 + $this1->a[1] * .7152 + $this1->a[2] * .0722;
	}
	static function toHsl($this1) {
		$tmp = Math::min($this1[0], $this1[1]);
		$min = Math::min($tmp, $this1[2]);
		$tmp1 = Math::max($this1[0], $this1[1]);
		$max = Math::max($tmp1, $this1[2]);
		$delta = $max - $min;
		$h = null;
		$s = null;
		$l = ($max + $min) / 2;
		$tmp2 = Math::abs($delta);
		if($tmp2 <= 1e-9) {
			$h = 0.0;
			$s = 0.0;
		} else {
			if($l < 0.5) {
				$s = $delta / ($max + $min);
			} else {
				$s = $delta / (2 - $max - $min);
			}
			if($this1[0] === $max) {
				$tmp3 = ($this1->a[1] - $this1[2]) / $delta;
				$tmp4 = null;
				$tmp5 = $this1[1];
				$tmp6 = thx_color__Rgbx_Rgbx_Impl_::get_blue($this1);
				if($tmp5 < $tmp6) {
					$tmp4 = 6;
				} else {
					$tmp4 = 0;
				}
				$h = $tmp3 + $tmp4;
			} else {
				if($this1[1] === $max) {
					$h = ($this1->a[2] - $this1[0]) / $delta + 2;
				} else {
					$h = ($this1->a[0] - $this1[1]) / $delta + 4;
				}
			}
			$h *= 60;
		}
		return (new _hx_array(array($h, $s, $l)));
	}
	static function toHsv($this1) {
		$tmp = Math::min($this1[0], $this1[1]);
		$min = Math::min($tmp, $this1[2]);
		$tmp1 = Math::max($this1[0], $this1[1]);
		$max = Math::max($tmp1, $this1[2]);
		$delta = $max - $min;
		$h = null;
		$s = null;
		if(!_hx_equal($delta, 0)) {
			$s = $delta / $max;
		} else {
			$s = 0;
			$h = -1;
			return (new _hx_array(array($h, $s, $max)));
		}
		if($this1[0] === $max) {
			$h = ($this1->a[1] - $this1[2]) / $delta;
		} else {
			if($this1[1] === $max) {
				$h = 2 + ($this1->a[2] - $this1[0]) / $delta;
			} else {
				$h = 4 + ($this1->a[0] - $this1[1]) / $delta;
			}
		}
		$h *= 60;
		$tmp2 = $h < 0;
		if($tmp2) {
			$h += 360;
		}
		return (new _hx_array(array($h, $s, $max)));
	}
	static function toHunterLab($this1) {
		$tmp = thx_color__Rgbx_Rgbx_Impl_::toXyz($this1);
		return thx_color__Xyz_Xyz_Impl_::toHunterLab($tmp);
	}
	static function toRgb($this1) {
		$red = Math::round($this1->a[0] * 255);
		$green = Math::round($this1->a[1] * 255);
		$blue = Math::round($this1->a[2] * 255);
		return ($red & 255) << 16 | ($green & 255) << 8 | $blue & 255;
	}
	static function toXyz($this1) {
		$r = $this1[0];
		$g = $this1[1];
		$b = $this1[2];
		if($r > 0.04045) {
			$r = Math::pow(($r + 0.055) / 1.055, 2.4);
		} else {
			$r /= 12.92;
		}
		if($g > 0.04045) {
			$g = Math::pow(($g + 0.055) / 1.055, 2.4);
		} else {
			$g /= 12.92;
		}
		if($b > 0.04045) {
			$b = Math::pow(($b + 0.055) / 1.055, 2.4);
		} else {
			$b /= 12.92;
		}
		return (new _hx_array(array($r * 0.4124564 + $g * 0.3575761 + $b * 0.1804375, $r * 0.2126729 + $g * 0.7151522 + $b * 0.0721750, $r * 0.0193339 + $g * 0.1191920 + $b * 0.9503041)));
	}
	static function toYuv($this1) {
		$r = $this1[0];
		$g = $this1[1];
		$b = $this1[2];
		return (new _hx_array(array(0.299 * $r + 0.587 * $g + 0.114 * $b, -0.14713 * $r - 0.28886 * $g + 0.436 * $b, 0.615 * $r - 0.51499 * $g - 0.10001 * $b)));
	}
	static function toYxy($this1) {
		$tmp = thx_color__Rgbx_Rgbx_Impl_::toXyz($this1);
		return thx_color__Xyz_Xyz_Impl_::toYxy($tmp);
	}
	static function get_blue($this1) {
		return Math::round($this1->a[2] * 255);
	}
	static $__properties__ = array("get_blue" => "get_blue");
	function __toString() { return 'thx.color._Rgbx.Rgbx_Impl_'; }
}
