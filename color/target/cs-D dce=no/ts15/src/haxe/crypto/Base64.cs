// Generated by Haxe 3.3.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.crypto {
	public class Base64 : global::haxe.lang.HxObject {
		
		static Base64() {
			global::haxe.crypto.Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
			global::haxe.crypto.Base64.BYTES = global::haxe.io.Bytes.ofString(global::haxe.crypto.Base64.CHARS);
		}
		
		
		public Base64(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Base64() {
			global::haxe.crypto.Base64.__hx_ctor_haxe_crypto_Base64(this);
		}
		
		
		public static void __hx_ctor_haxe_crypto_Base64(global::haxe.crypto.Base64 __temp_me52) {
		}
		
		
		public static string CHARS;
		
		public static global::haxe.io.Bytes BYTES;
		
		public static string encode(global::haxe.io.Bytes bytes, global::haxe.lang.Null<bool> complement) {
			unchecked {
				bool __temp_complement50 = ( ( ! (complement.hasValue) ) ? (true) : ((complement).@value) );
				string str = new global::haxe.crypto.BaseCode(((global::haxe.io.Bytes) (global::haxe.crypto.Base64.BYTES) )).encodeBytes(bytes).toString();
				if (__temp_complement50) {
					switch (( bytes.length % 3 )) {
						case 1:
						{
							str = global::haxe.lang.Runtime.concat(str, "==");
							break;
						}
						
						
						case 2:
						{
							str = global::haxe.lang.Runtime.concat(str, "=");
							break;
						}
						
						
						default:
						{
							break;
						}
						
					}
					
				}
				
				return str;
			}
		}
		
		
		public static global::haxe.io.Bytes decode(string str, global::haxe.lang.Null<bool> complement) {
			unchecked {
				bool __temp_complement51 = ( ( ! (complement.hasValue) ) ? (true) : ((complement).@value) );
				if (__temp_complement51) {
					while (global::haxe.lang.Runtime.eq((global::haxe.lang.StringExt.charCodeAt(str, ( str.Length - 1 ))).toDynamic(), 61)) {
						str = global::haxe.lang.StringExt.substr(str, 0, new global::haxe.lang.Null<int>(-1, true));
					}
					
				}
				
				return new global::haxe.crypto.BaseCode(((global::haxe.io.Bytes) (global::haxe.crypto.Base64.BYTES) )).decodeBytes(global::haxe.io.Bytes.ofString(str));
			}
		}
		
		
		public static new object __hx_createEmpty() {
			return new global::haxe.crypto.Base64(global::haxe.lang.EmptyObject.EMPTY);
		}
		
		
		public static new object __hx_create(global::Array arr) {
			return new global::haxe.crypto.Base64();
		}
		
		
	}
}


