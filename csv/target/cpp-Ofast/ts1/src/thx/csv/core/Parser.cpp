// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringBuf
#include <StringBuf.h>
#endif
#ifndef INCLUDED_haxe_StackItem
#include <haxe/StackItem.h>
#endif
#ifndef INCLUDED_thx_Error
#include <thx/Error.h>
#endif
#ifndef INCLUDED_thx_csv_core_Parser
#include <thx/csv/core/Parser.h>
#endif

namespace thx{
namespace csv{
namespace core{

void Parser_obj::__construct(::String delimiter,::String quote,::String escapedQuote){
            	HX_STACK_FRAME("thx.csv.core.Parser","new",0x61b6168e,"thx.csv.core.Parser.new","thx/csv/core/Parser.hx",10,0xa687a083)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(delimiter,"delimiter")
            	HX_STACK_ARG(quote,"quote")
            	HX_STACK_ARG(escapedQuote,"escapedQuote")
HXLINE(  11)		this->delimiter = delimiter;
HXLINE(  12)		this->quote = quote;
HXLINE(  13)		this->escapedQuote = escapedQuote;
            	}

Dynamic Parser_obj::__CreateEmpty() { return new Parser_obj; }

hx::ObjectPtr< Parser_obj > Parser_obj::__new(::String delimiter,::String quote,::String escapedQuote)
{
	hx::ObjectPtr< Parser_obj > _hx_result = new Parser_obj();
	_hx_result->__construct(delimiter,quote,escapedQuote);
	return _hx_result;
}

Dynamic Parser_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Parser_obj > _hx_result = new Parser_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

::Array< ::Dynamic> Parser_obj::parse(::String s){
            	HX_STACK_FRAME("thx.csv.core.Parser","parse",0xf0783de1,"thx.csv.core.Parser.parse","thx/csv/core/Parser.hx",25,0xa687a083)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(s,"s")
HXLINE(  26)		this->s = s;
HXLINE(  27)		this->result = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  28)		this->pos = (int)0;
HXLINE(  29)		this->len = s.length;
HXLINE(  30)		this->delimiterLength = this->delimiter.length;
HXLINE(  31)		this->quoteLength = this->quote.length;
HXLINE(  32)		this->escapedQuoteLength = this->escapedQuote.length;
HXLINE(  33)		this->buffer =  ::StringBuf_obj::__new();
HXLINE(  34)		this->row = ::Array_obj< ::String >::__new(0);
HXLINE(  36)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  37)			HX_VAR( ::String,t);
HXDLIN(  37)			while((this->pos < this->len)){
HXLINE(  37)				Bool _hx_tmp;
HXDLIN(  37)				Int _hx_tmp1 = this->pos;
HXDLIN(  37)				Int _hx_tmp2 = (this->pos + this->quoteLength);
HXDLIN(  37)				::String _hx_tmp3 = this->s.substring(_hx_tmp1,_hx_tmp2);
HXDLIN(  37)				if ((_hx_tmp3 == this->quote)) {
HXLINE(  37)					Int _hx_tmp4 = this->buffer->get_length();
HXDLIN(  37)					_hx_tmp = (_hx_tmp4 == (int)0);
            				}
            				else {
HXLINE(  37)					_hx_tmp = false;
            				}
HXDLIN(  37)				if (_hx_tmp) {
HXLINE(  37)					hx::AddEq(this->pos,this->quoteLength);
HXDLIN(  37)					while((this->pos < this->len)){
HXLINE(  37)						Int _hx_tmp5 = this->pos;
HXDLIN(  37)						Int _hx_tmp6 = (this->pos + this->escapedQuoteLength);
HXDLIN(  37)						::String _hx_tmp7 = this->s.substring(_hx_tmp5,_hx_tmp6);
HXDLIN(  37)						if ((_hx_tmp7 == this->escapedQuote)) {
HXLINE(  37)							this->pushBuffer(this->quote);
HXDLIN(  37)							hx::AddEq(this->pos,this->escapedQuoteLength);
            						}
            						else {
HXLINE(  37)							Int _hx_tmp8 = this->pos;
HXDLIN(  37)							Int _hx_tmp9 = (this->pos + this->quoteLength);
HXDLIN(  37)							::String _hx_tmp10 = this->s.substring(_hx_tmp8,_hx_tmp9);
HXDLIN(  37)							if ((_hx_tmp10 == this->quote)) {
HXLINE(  37)								hx::AddEq(this->pos,this->quoteLength);
HXDLIN(  37)								Int _hx_tmp11 = this->pos;
HXDLIN(  37)								Int _hx_tmp12 = (this->pos + (int)1);
HXDLIN(  37)								HX_VARI( ::String,next) = this->s.substring(_hx_tmp11,_hx_tmp12);
HXDLIN(  37)								while(true){
HXLINE(  37)									Bool _hx_tmp13;
HXDLIN(  37)									if ((next != HX_(" ",20,00,00,00))) {
HXLINE(  37)										if ((this->delimiter != HX_("\t",09,00,00,00))) {
HXLINE(  37)											_hx_tmp13 = (next == HX_("\t",09,00,00,00));
            										}
            										else {
HXLINE(  37)											_hx_tmp13 = false;
            										}
            									}
            									else {
HXLINE(  37)										_hx_tmp13 = true;
            									}
HXDLIN(  37)									if (!(_hx_tmp13)) {
HXLINE(  37)										goto _hx_goto_2;
            									}
HXDLIN(  37)									++this->pos;
HXDLIN(  37)									Int _hx_tmp14 = this->pos;
HXDLIN(  37)									Int _hx_tmp15 = (this->pos + (int)1);
HXDLIN(  37)									next = this->s.substring(_hx_tmp14,_hx_tmp15);
            								}
            								_hx_goto_2:;
HXDLIN(  37)								goto _hx_goto_1;
            							}
            							else {
HXLINE(  37)								Int _hx_tmp16 = this->pos;
HXDLIN(  37)								Int _hx_tmp17 = (this->pos + (int)1);
HXDLIN(  37)								::String _hx_tmp18 = this->s.substring(_hx_tmp16,_hx_tmp17);
HXDLIN(  37)								this->pushBuffer(_hx_tmp18);
HXDLIN(  37)								++this->pos;
            							}
            						}
            					}
            					_hx_goto_1:;
            				}
            				else {
HXLINE(  37)					Int _hx_tmp19 = this->pos;
HXDLIN(  37)					Int _hx_tmp20 = (this->pos + this->delimiterLength);
HXDLIN(  37)					::String _hx_tmp21 = this->s.substring(_hx_tmp19,_hx_tmp20);
HXDLIN(  37)					if ((_hx_tmp21 == this->delimiter)) {
HXLINE(  37)						this->pushCell();
HXDLIN(  37)						hx::AddEq(this->pos,this->delimiterLength);
            					}
            					else {
HXLINE(  37)						Int _hx_tmp22 = this->pos;
HXDLIN(  37)						Int _hx_tmp23 = (this->pos + (int)2);
HXDLIN(  37)						t = this->s.substring(_hx_tmp22,_hx_tmp23);
HXDLIN(  37)						Bool _hx_tmp24;
HXDLIN(  37)						if ((t != HX_("\n\r",c3,08,00,00))) {
HXLINE(  37)							_hx_tmp24 = (t == HX_("\r\n",5d,0b,00,00));
            						}
            						else {
HXLINE(  37)							_hx_tmp24 = true;
            						}
HXDLIN(  37)						if (_hx_tmp24) {
HXLINE(  37)							hx::AddEq(this->pos,(int)2);
HXDLIN(  37)							this->pushCell();
HXDLIN(  37)							this->pushRow();
HXDLIN(  37)							continue;
            						}
HXDLIN(  37)						Int _hx_tmp25 = this->pos;
HXDLIN(  37)						Int _hx_tmp26 = (this->pos + (int)1);
HXDLIN(  37)						t = this->s.substring(_hx_tmp25,_hx_tmp26);
HXDLIN(  37)						Bool _hx_tmp27;
HXDLIN(  37)						if ((t != HX_("\n",0a,00,00,00))) {
HXLINE(  37)							_hx_tmp27 = (t == HX_("\r",0d,00,00,00));
            						}
            						else {
HXLINE(  37)							_hx_tmp27 = true;
            						}
HXDLIN(  37)						if (_hx_tmp27) {
HXLINE(  37)							++this->pos;
HXDLIN(  37)							this->pushCell();
HXDLIN(  37)							this->pushRow();
HXDLIN(  37)							continue;
            						}
HXDLIN(  37)						Int _hx_tmp28 = this->pos;
HXDLIN(  37)						Int _hx_tmp29 = (this->pos + (int)1);
HXDLIN(  37)						::String _hx_tmp30 = this->s.substring(_hx_tmp28,_hx_tmp29);
HXDLIN(  37)						this->pushBuffer(_hx_tmp30);
HXDLIN(  37)						++this->pos;
            					}
            				}
            			}
            		}
            		catch( ::Dynamic _hx_e){
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic e = _hx_e;
HXLINE(  39)				::String _hx_tmp31 = ((HX_("unable to parse at pos ",54,9a,58,53) + this->pos) + HX_(": ",a6,32,00,00));
HXDLIN(  39)				::String _hx_tmp32 = ::Std_obj::string(e);
HXDLIN(  39)				HX_STACK_DO_THROW( ::thx::Error_obj::__new((_hx_tmp31 + _hx_tmp32),null(),hx::SourceInfo(HX_("Parser.hx",1f,9b,1d,8a),39,HX_("thx.csv.core.Parser",9c,77,70,49),HX_("parse",33,90,55,bd))));
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE(  41)		this->pushCell();
HXLINE(  42)		this->pushRow();
HXLINE(  44)		return this->result;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Parser_obj,parse,return )

void Parser_obj::pushCell(){
            	HX_STACK_FRAME("thx.csv.core.Parser","pushCell",0xcbb8e7ae,"thx.csv.core.Parser.pushCell","thx/csv/core/Parser.hx",47,0xa687a083)
            	HX_STACK_THIS(this)
HXLINE(  48)		::String _hx_tmp = this->buffer->b->join(HX_("",00,00,00,00));
HXDLIN(  48)		this->row->push(_hx_tmp);
HXLINE(  49)		this->buffer =  ::StringBuf_obj::__new();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,pushCell,(void))

void Parser_obj::pushBuffer(::String _hx_char){
            	HX_STACK_FRAME("thx.csv.core.Parser","pushBuffer",0xa5971e0c,"thx.csv.core.Parser.pushBuffer","thx/csv/core/Parser.hx",53,0xa687a083)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(_hx_char,"char")
HXLINE(  53)		this->buffer->add(_hx_char);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Parser_obj,pushBuffer,(void))

void Parser_obj::pushRow(){
            	HX_STACK_FRAME("thx.csv.core.Parser","pushRow",0xb8a2a18e,"thx.csv.core.Parser.pushRow","thx/csv/core/Parser.hx",56,0xa687a083)
            	HX_STACK_THIS(this)
HXLINE(  57)		this->result->push(this->row);
HXLINE(  58)		this->row = ::Array_obj< ::String >::__new(0);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,pushRow,(void))

void Parser_obj::loop(){
            	HX_STACK_FRAME("thx.csv.core.Parser","loop",0x1c52c876,"thx.csv.core.Parser.loop","thx/csv/core/Parser.hx",61,0xa687a083)
            	HX_STACK_THIS(this)
HXLINE(  62)		HX_VAR( ::String,t);
HXLINE(  63)		while((this->pos < this->len)){
HXLINE(  64)			Bool _hx_tmp;
HXDLIN(  64)			Int _hx_tmp1 = this->pos;
HXDLIN(  64)			Int _hx_tmp2 = (this->pos + this->quoteLength);
HXDLIN(  64)			::String _hx_tmp3 = this->s.substring(_hx_tmp1,_hx_tmp2);
HXDLIN(  64)			if ((_hx_tmp3 == this->quote)) {
HXLINE(  64)				Int _hx_tmp4 = this->buffer->get_length();
HXDLIN(  64)				_hx_tmp = (_hx_tmp4 == (int)0);
            			}
            			else {
HXLINE(  64)				_hx_tmp = false;
            			}
HXDLIN(  64)			if (_hx_tmp) {
HXLINE(  65)				hx::AddEq(this->pos,this->quoteLength);
HXLINE(  67)				while((this->pos < this->len)){
HXLINE(  68)					Int _hx_tmp5 = this->pos;
HXDLIN(  68)					Int _hx_tmp6 = (this->pos + this->escapedQuoteLength);
HXDLIN(  68)					::String _hx_tmp7 = this->s.substring(_hx_tmp5,_hx_tmp6);
HXDLIN(  68)					if ((_hx_tmp7 == this->escapedQuote)) {
HXLINE(  69)						this->pushBuffer(this->quote);
HXLINE(  70)						hx::AddEq(this->pos,this->escapedQuoteLength);
            					}
            					else {
HXLINE(  71)						Int _hx_tmp8 = this->pos;
HXDLIN(  71)						Int _hx_tmp9 = (this->pos + this->quoteLength);
HXDLIN(  71)						::String _hx_tmp10 = this->s.substring(_hx_tmp8,_hx_tmp9);
HXDLIN(  71)						if ((_hx_tmp10 == this->quote)) {
HXLINE(  72)							hx::AddEq(this->pos,this->quoteLength);
HXLINE(  73)							Int _hx_tmp11 = this->pos;
HXDLIN(  73)							Int _hx_tmp12 = (this->pos + (int)1);
HXDLIN(  73)							HX_VARI( ::String,next) = this->s.substring(_hx_tmp11,_hx_tmp12);
HXLINE(  74)							while(true){
HXLINE(  74)								Bool _hx_tmp13;
HXDLIN(  74)								if ((next != HX_(" ",20,00,00,00))) {
HXLINE(  74)									if ((this->delimiter != HX_("\t",09,00,00,00))) {
HXLINE(  74)										_hx_tmp13 = (next == HX_("\t",09,00,00,00));
            									}
            									else {
HXLINE(  74)										_hx_tmp13 = false;
            									}
            								}
            								else {
HXLINE(  74)									_hx_tmp13 = true;
            								}
HXDLIN(  74)								if (!(_hx_tmp13)) {
HXLINE(  74)									goto _hx_goto_5;
            								}
HXLINE(  75)								++this->pos;
HXLINE(  76)								Int _hx_tmp14 = this->pos;
HXDLIN(  76)								Int _hx_tmp15 = (this->pos + (int)1);
HXDLIN(  76)								next = this->s.substring(_hx_tmp14,_hx_tmp15);
            							}
            							_hx_goto_5:;
HXLINE(  78)							goto _hx_goto_4;
            						}
            						else {
HXLINE(  80)							Int _hx_tmp16 = this->pos;
HXDLIN(  80)							Int _hx_tmp17 = (this->pos + (int)1);
HXDLIN(  80)							::String _hx_tmp18 = this->s.substring(_hx_tmp16,_hx_tmp17);
HXDLIN(  80)							this->pushBuffer(_hx_tmp18);
HXLINE(  81)							++this->pos;
            						}
            					}
            				}
            				_hx_goto_4:;
            			}
            			else {
HXLINE(  84)				Int _hx_tmp19 = this->pos;
HXDLIN(  84)				Int _hx_tmp20 = (this->pos + this->delimiterLength);
HXDLIN(  84)				::String _hx_tmp21 = this->s.substring(_hx_tmp19,_hx_tmp20);
HXDLIN(  84)				if ((_hx_tmp21 == this->delimiter)) {
HXLINE(  85)					this->pushCell();
HXLINE(  86)					hx::AddEq(this->pos,this->delimiterLength);
            				}
            				else {
HXLINE(  88)					Int _hx_tmp22 = this->pos;
HXDLIN(  88)					Int _hx_tmp23 = (this->pos + (int)2);
HXDLIN(  88)					t = this->s.substring(_hx_tmp22,_hx_tmp23);
HXLINE(  89)					Bool _hx_tmp24;
HXDLIN(  89)					if ((t != HX_("\n\r",c3,08,00,00))) {
HXLINE(  89)						_hx_tmp24 = (t == HX_("\r\n",5d,0b,00,00));
            					}
            					else {
HXLINE(  89)						_hx_tmp24 = true;
            					}
HXDLIN(  89)					if (_hx_tmp24) {
HXLINE(  90)						hx::AddEq(this->pos,(int)2);
HXLINE(  91)						this->pushCell();
HXLINE(  92)						this->pushRow();
HXLINE(  93)						continue;
            					}
HXLINE(  95)					Int _hx_tmp25 = this->pos;
HXDLIN(  95)					Int _hx_tmp26 = (this->pos + (int)1);
HXDLIN(  95)					t = this->s.substring(_hx_tmp25,_hx_tmp26);
HXLINE(  96)					Bool _hx_tmp27;
HXDLIN(  96)					if ((t != HX_("\n",0a,00,00,00))) {
HXLINE(  96)						_hx_tmp27 = (t == HX_("\r",0d,00,00,00));
            					}
            					else {
HXLINE(  96)						_hx_tmp27 = true;
            					}
HXDLIN(  96)					if (_hx_tmp27) {
HXLINE(  97)						++this->pos;
HXLINE(  98)						this->pushCell();
HXLINE(  99)						this->pushRow();
HXLINE( 100)						continue;
            					}
HXLINE( 102)					Int _hx_tmp28 = this->pos;
HXDLIN( 102)					Int _hx_tmp29 = (this->pos + (int)1);
HXDLIN( 102)					::String _hx_tmp30 = this->s.substring(_hx_tmp28,_hx_tmp29);
HXDLIN( 102)					this->pushBuffer(_hx_tmp30);
HXLINE( 103)					++this->pos;
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Parser_obj,loop,(void))


Parser_obj::Parser_obj()
{
}

void Parser_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Parser);
	HX_MARK_MEMBER_NAME(delimiter,"delimiter");
	HX_MARK_MEMBER_NAME(quote,"quote");
	HX_MARK_MEMBER_NAME(escapedQuote,"escapedQuote");
	HX_MARK_MEMBER_NAME(result,"result");
	HX_MARK_MEMBER_NAME(pos,"pos");
	HX_MARK_MEMBER_NAME(len,"len");
	HX_MARK_MEMBER_NAME(delimiterLength,"delimiterLength");
	HX_MARK_MEMBER_NAME(quoteLength,"quoteLength");
	HX_MARK_MEMBER_NAME(escapedQuoteLength,"escapedQuoteLength");
	HX_MARK_MEMBER_NAME(buffer,"buffer");
	HX_MARK_MEMBER_NAME(row,"row");
	HX_MARK_MEMBER_NAME(s,"s");
	HX_MARK_END_CLASS();
}

void Parser_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(delimiter,"delimiter");
	HX_VISIT_MEMBER_NAME(quote,"quote");
	HX_VISIT_MEMBER_NAME(escapedQuote,"escapedQuote");
	HX_VISIT_MEMBER_NAME(result,"result");
	HX_VISIT_MEMBER_NAME(pos,"pos");
	HX_VISIT_MEMBER_NAME(len,"len");
	HX_VISIT_MEMBER_NAME(delimiterLength,"delimiterLength");
	HX_VISIT_MEMBER_NAME(quoteLength,"quoteLength");
	HX_VISIT_MEMBER_NAME(escapedQuoteLength,"escapedQuoteLength");
	HX_VISIT_MEMBER_NAME(buffer,"buffer");
	HX_VISIT_MEMBER_NAME(row,"row");
	HX_VISIT_MEMBER_NAME(s,"s");
}

hx::Val Parser_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"s") ) { return hx::Val( s); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pos") ) { return hx::Val( pos); }
		if (HX_FIELD_EQ(inName,"len") ) { return hx::Val( len); }
		if (HX_FIELD_EQ(inName,"row") ) { return hx::Val( row); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"loop") ) { return hx::Val( loop_dyn()); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"quote") ) { return hx::Val( quote); }
		if (HX_FIELD_EQ(inName,"parse") ) { return hx::Val( parse_dyn()); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"result") ) { return hx::Val( result); }
		if (HX_FIELD_EQ(inName,"buffer") ) { return hx::Val( buffer); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"pushRow") ) { return hx::Val( pushRow_dyn()); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"pushCell") ) { return hx::Val( pushCell_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"delimiter") ) { return hx::Val( delimiter); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"pushBuffer") ) { return hx::Val( pushBuffer_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"quoteLength") ) { return hx::Val( quoteLength); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"escapedQuote") ) { return hx::Val( escapedQuote); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"delimiterLength") ) { return hx::Val( delimiterLength); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"escapedQuoteLength") ) { return hx::Val( escapedQuoteLength); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Parser_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"s") ) { s=inValue.Cast< ::String >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"pos") ) { pos=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"len") ) { len=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"row") ) { row=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"quote") ) { quote=inValue.Cast< ::String >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"result") ) { result=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"buffer") ) { buffer=inValue.Cast<  ::StringBuf >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"delimiter") ) { delimiter=inValue.Cast< ::String >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"quoteLength") ) { quoteLength=inValue.Cast< Int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"escapedQuote") ) { escapedQuote=inValue.Cast< ::String >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"delimiterLength") ) { delimiterLength=inValue.Cast< Int >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"escapedQuoteLength") ) { escapedQuoteLength=inValue.Cast< Int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Parser_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("delimiter","\x07","\x07","\x28","\x86"));
	outFields->push(HX_HCSTRING("quote","\x3c","\x23","\xf2","\x5d"));
	outFields->push(HX_HCSTRING("escapedQuote","\x79","\x02","\x8f","\x79"));
	outFields->push(HX_HCSTRING("result","\xdd","\x68","\x84","\x08"));
	outFields->push(HX_HCSTRING("pos","\x94","\x5d","\x55","\x00"));
	outFields->push(HX_HCSTRING("len","\xd5","\x4b","\x52","\x00"));
	outFields->push(HX_HCSTRING("delimiterLength","\x4d","\x8f","\x19","\xa1"));
	outFields->push(HX_HCSTRING("quoteLength","\x42","\x41","\x52","\x61"));
	outFields->push(HX_HCSTRING("escapedQuoteLength","\x3f","\xac","\xfd","\x34"));
	outFields->push(HX_HCSTRING("buffer","\x00","\xbd","\x94","\xd0"));
	outFields->push(HX_HCSTRING("row","\x1a","\xe2","\x56","\x00"));
	outFields->push(HX_HCSTRING("s","\x73","\x00","\x00","\x00"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Parser_obj_sMemberStorageInfo[] = {
	{hx::fsString,(int)offsetof(Parser_obj,delimiter),HX_HCSTRING("delimiter","\x07","\x07","\x28","\x86")},
	{hx::fsString,(int)offsetof(Parser_obj,quote),HX_HCSTRING("quote","\x3c","\x23","\xf2","\x5d")},
	{hx::fsString,(int)offsetof(Parser_obj,escapedQuote),HX_HCSTRING("escapedQuote","\x79","\x02","\x8f","\x79")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Parser_obj,result),HX_HCSTRING("result","\xdd","\x68","\x84","\x08")},
	{hx::fsInt,(int)offsetof(Parser_obj,pos),HX_HCSTRING("pos","\x94","\x5d","\x55","\x00")},
	{hx::fsInt,(int)offsetof(Parser_obj,len),HX_HCSTRING("len","\xd5","\x4b","\x52","\x00")},
	{hx::fsInt,(int)offsetof(Parser_obj,delimiterLength),HX_HCSTRING("delimiterLength","\x4d","\x8f","\x19","\xa1")},
	{hx::fsInt,(int)offsetof(Parser_obj,quoteLength),HX_HCSTRING("quoteLength","\x42","\x41","\x52","\x61")},
	{hx::fsInt,(int)offsetof(Parser_obj,escapedQuoteLength),HX_HCSTRING("escapedQuoteLength","\x3f","\xac","\xfd","\x34")},
	{hx::fsObject /*::StringBuf*/ ,(int)offsetof(Parser_obj,buffer),HX_HCSTRING("buffer","\x00","\xbd","\x94","\xd0")},
	{hx::fsObject /*Array< ::String >*/ ,(int)offsetof(Parser_obj,row),HX_HCSTRING("row","\x1a","\xe2","\x56","\x00")},
	{hx::fsString,(int)offsetof(Parser_obj,s),HX_HCSTRING("s","\x73","\x00","\x00","\x00")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Parser_obj_sStaticStorageInfo = 0;
#endif

static ::String Parser_obj_sMemberFields[] = {
	HX_HCSTRING("delimiter","\x07","\x07","\x28","\x86"),
	HX_HCSTRING("quote","\x3c","\x23","\xf2","\x5d"),
	HX_HCSTRING("escapedQuote","\x79","\x02","\x8f","\x79"),
	HX_HCSTRING("result","\xdd","\x68","\x84","\x08"),
	HX_HCSTRING("pos","\x94","\x5d","\x55","\x00"),
	HX_HCSTRING("len","\xd5","\x4b","\x52","\x00"),
	HX_HCSTRING("delimiterLength","\x4d","\x8f","\x19","\xa1"),
	HX_HCSTRING("quoteLength","\x42","\x41","\x52","\x61"),
	HX_HCSTRING("escapedQuoteLength","\x3f","\xac","\xfd","\x34"),
	HX_HCSTRING("buffer","\x00","\xbd","\x94","\xd0"),
	HX_HCSTRING("row","\x1a","\xe2","\x56","\x00"),
	HX_HCSTRING("s","\x73","\x00","\x00","\x00"),
	HX_HCSTRING("parse","\x33","\x90","\x55","\xbd"),
	HX_HCSTRING("pushCell","\x9c","\x54","\xae","\x10"),
	HX_HCSTRING("pushBuffer","\x7a","\x22","\x74","\x24"),
	HX_HCSTRING("pushRow","\x60","\xac","\x36","\x75"),
	HX_HCSTRING("loop","\x64","\xa6","\xb7","\x47"),
	::String(null()) };

static void Parser_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Parser_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Parser_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Parser_obj::__mClass,"__mClass");
};

#endif

hx::Class Parser_obj::__mClass;

void Parser_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("thx.csv.core.Parser","\x9c","\x77","\x70","\x49");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Parser_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Parser_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Parser_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Parser_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Parser_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Parser_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace thx
} // end namespace csv
} // end namespace core
