<?php

// Generated by Haxe 3.3.0
class thx_csv_core_Parser {
	public function __construct($delimiter, $quote, $escapedQuote) {
		if(!php_Boot::$skip_constructor) {
		$this->delimiter = $delimiter;
		$this->quote = $quote;
		$this->escapedQuote = $escapedQuote;
	}}
	public $delimiter;
	public $quote;
	public $escapedQuote;
	public $result;
	public $pos;
	public $len;
	public $delimiterLength;
	public $quoteLength;
	public $escapedQuoteLength;
	public $buffer;
	public $row;
	public $s;
	public function parse($s) {
		$this->s = $s;
		$this->result = (new _hx_array(array()));
		$this->pos = 0;
		$this->len = strlen($s);
		$this->delimiterLength = strlen($this->delimiter);
		$this->quoteLength = strlen($this->quote);
		$this->escapedQuoteLength = strlen($this->escapedQuote);
		$this->buffer = new StringBuf();
		$this->row = (new _hx_array(array()));
		try {
			$this->loop();
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{
				$tmp = "unable to parse at pos " . _hx_string_rec($this->pos, "") . ": ";
				$tmp1 = Std::string($e);
				throw new HException(new thx_Error(_hx_string_or_null($tmp) . _hx_string_or_null($tmp1), null, _hx_anonymous(array("fileName" => "Parser.hx", "lineNumber" => 39, "className" => "thx.csv.core.Parser", "methodName" => "parse"))));
			}
		}
		$this->pushCell();
		$this->pushRow();
		return $this->result;
	}
	public function pushCell() {
		$tmp = $this->buffer->toString();
		$this->row->push($tmp);
		$this->buffer = new StringBuf();
	}
	public function pushBuffer($char) {
		$this->buffer->add($char);
	}
	public function pushRow() {
		$this->result->push($this->row);
		$this->row = (new _hx_array(array()));
	}
	public function loop() {
		$t = null;
		while($this->pos < $this->len) {
			$tmp = null;
			$tmp1 = $this->pos;
			$tmp2 = $this->pos + $this->quoteLength;
			$tmp3 = _hx_substring($this->s, $tmp1, $tmp2);
			if($tmp3 === $this->quote) {
				$tmp4 = $this->buffer->get_length();
				$tmp = $tmp4 === 0;
				unset($tmp4);
			} else {
				$tmp = false;
			}
			if($tmp) {
				$this->pos += $this->quoteLength;
				while($this->pos < $this->len) {
					$tmp5 = $this->pos;
					$tmp6 = $this->pos + $this->escapedQuoteLength;
					$tmp7 = _hx_substring($this->s, $tmp5, $tmp6);
					if($tmp7 === $this->escapedQuote) {
						$this->pushBuffer($this->quote);
						$this->pos += $this->escapedQuoteLength;
					} else {
						$tmp8 = $this->pos;
						$tmp9 = $this->pos + $this->quoteLength;
						$tmp10 = _hx_substring($this->s, $tmp8, $tmp9);
						if($tmp10 === $this->quote) {
							$this->pos += $this->quoteLength;
							$tmp11 = $this->pos;
							$tmp12 = $this->pos + 1;
							$next = _hx_substring($this->s, $tmp11, $tmp12);
							while(true) {
								$tmp13 = null;
								if($next !== " ") {
									if($this->delimiter !== "\x09") {
										$tmp13 = $next === "\x09";
									} else {
										$tmp13 = false;
									}
								} else {
									$tmp13 = true;
								}
								if(!$tmp13) {
									break;
								}
								++$this->pos;
								$tmp14 = $this->pos;
								$tmp15 = $this->pos + 1;
								$next = _hx_substring($this->s, $tmp14, $tmp15);
								unset($tmp15,$tmp14,$tmp13);
							}
							break;
							unset($tmp12,$tmp11,$next);
						} else {
							$tmp16 = $this->pos;
							$tmp17 = $this->pos + 1;
							$tmp18 = _hx_substring($this->s, $tmp16, $tmp17);
							$this->pushBuffer($tmp18);
							++$this->pos;
							unset($tmp18,$tmp17,$tmp16);
						}
						unset($tmp9,$tmp8,$tmp10);
					}
					unset($tmp7,$tmp6,$tmp5);
				}
			} else {
				$tmp19 = $this->pos;
				$tmp20 = $this->pos + $this->delimiterLength;
				$tmp21 = _hx_substring($this->s, $tmp19, $tmp20);
				if($tmp21 === $this->delimiter) {
					$this->pushCell();
					$this->pos += $this->delimiterLength;
				} else {
					$tmp22 = $this->pos;
					$tmp23 = $this->pos + 2;
					$t = _hx_substring($this->s, $tmp22, $tmp23);
					$tmp24 = null;
					if($t !== "\x0A\x0D") {
						$tmp24 = $t === "\x0D\x0A";
					} else {
						$tmp24 = true;
					}
					if($tmp24) {
						$this->pos += 2;
						$this->pushCell();
						$this->pushRow();
						continue;
					}
					$tmp25 = $this->pos;
					$tmp26 = $this->pos + 1;
					$t = _hx_substring($this->s, $tmp25, $tmp26);
					$tmp27 = null;
					if($t !== "\x0A") {
						$tmp27 = $t === "\x0D";
					} else {
						$tmp27 = true;
					}
					if($tmp27) {
						++$this->pos;
						$this->pushCell();
						$this->pushRow();
						continue;
					}
					$tmp28 = $this->pos;
					$tmp29 = $this->pos + 1;
					$tmp30 = _hx_substring($this->s, $tmp28, $tmp29);
					$this->pushBuffer($tmp30);
					++$this->pos;
					unset($tmp30,$tmp29,$tmp28,$tmp27,$tmp26,$tmp25,$tmp24,$tmp23,$tmp22);
				}
				unset($tmp21,$tmp20,$tmp19);
			}
			unset($tmp3,$tmp2,$tmp1,$tmp);
		}
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'thx.csv.core.Parser'; }
}
