// Generated by Haxe 3.3.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldLookup {
		
		#pragma warning disable 628
		static FieldLookup() {
			global::haxe.lang.FieldLookup.length = ( global::haxe.lang.FieldLookup.fieldIds as global::System.Array ).Length;
		}
		
		
		public FieldLookup() {
		}
		
		
		protected static int[] fieldIds = new int[]{98, 102, 104, 105, 107, 109, 113, 116, 120, 21233, 21234, 21235, 21236, 21237, 21238, 24422, 1332402, 1821933, 4745537, 4745538, 4846113, 4849249, 4947370, 4949376, 4995541, 4996429, 5047484, 5049505, 5144726, 5145602, 5193562, 5243965, 5246186, 5343647, 5393365, 5442204, 5442212, 5443986, 5594513, 5594516, 5695307, 5741474, 5745024, 5745035, 5790526, 5841808, 10319920, 24046298, 25738091, 26061316, 39622016, 42740551, 43737796, 46374763, 52644165, 57219237, 63559312, 67859554, 67859999, 68006728, 69718249, 72252782, 72452854, 74822897, 76061764, 78447857, 87367608, 95523933, 96903864, 99632527, 103479213, 109574339, 116192081, 125111323, 130476146, 132916898, 133414859, 142301684, 142895325, 143865495, 156956385, 159136996, 160217260, 172955042, 179047623, 188431961, 207609411, 212244564, 222029606, 226931207, 240155668, 243225909, 244830897, 252173918, 252174139, 252174360, 261031087, 262801146, 265544154, 270118404, 281751194, 286437776, 288025444, 288167040, 288368849, 302437830, 302979532, 307312293, 309502035, 311106773, 311106994, 314003042, 328878574, 334695532, 336655392, 350619104, 350619108, 353204262, 358990357, 359333139, 388680308, 391692349, 399964207, 400509660, 401985360, 407283053, 409871691, 414504008, 418482770, 437335495, 440996547, 451001976, 452737314, 478746067, 480756972, 482248426, 484018937, 493819893, 499574632, 501039929, 502768344, 502769015, 506461556, 509857466, 520590566, 520665567, 528448451, 530261339, 542823803, 552155691, 563316893, 572311959, 589000550, 589599061, 591404329, 596483356, 596496232, 610723709, 614073432, 623100778, 625308696, 640252688, 641357653, 641535602, 645255902, 650414942, 651890926, 674203586, 688014215, 691754853, 703544457, 724060212, 727985871, 729151262, 735026061, 735461151, 742854407, 767112783, 772311838, 772312059, 790737991, 815911746, 834174833, 843587180, 845179051, 845339077, 872071561, 887376854, 887574448, 891567758, 897845290, 910198946, 922037898, 922671056, 927738905, 930986349, 930987020, 934297389, 937267591, 946786476, 959399230, 961866285, 971992536, 985194240, 992442663, 993950564, 995006396, 999967216, 1002257126, 1035643931, 1035697007, 1036388972, 1046660463, 1058556349, 1067353468, 1071652316, 1072885311, 1084792286, 1091627025, 1092171829, 1099121107, 1102421591, 1102715038, 1103412149, 1111933837, 1113806382, 1113807511, 1114501250, 1126920507, 1136381564, 1136381571, 1145269635, 1152408707, 1154932936, 1155848147, 1158359328, 1170141094, 1170195731, 1171632074, 1172057283, 1181037546, 1191633396, 1191829406, 1202522710, 1202718727, 1202920542, 1204059472, 1204816148, 1212528822, 1213952397, 1214305123, 1214453688, 1224901875, 1225397154, 1227765365, 1230265810, 1232990044, 1234680156, 1238832007, 1245800482, 1246877401, 1246881189, 1247723251, 1247875320, 1247875546, 1257939113, 1269206179, 1269254998, 1269755426, 1271070480, 1273207865, 1275922997, 1280345464, 1280549057, 1280638028, 1280638699, 1280845662, 1281091404, 1281093634, 1282943179, 1291299698, 1291436593, 1302870512, 1309344294, 1313416818, 1315911912, 1323398036, 1324505717, 1324905541, 1327743821, 1329111435, 1337394146, 1348037855, 1352786672, 1357975336, 1365803947, 1381630732, 1390395051, 1390578741, 1390578962, 1390579183, 1395555037, 1400771174, 1407096607, 1413779326, 1428431209, 1428901784, 1429408506, 1429883725, 1429887281, 1447008734, 1457436259, 1462163331, 1491961287, 1492589217, 1503837296, 1504438184, 1516540973, 1519236735, 1531583505, 1532710347, 1537812987, 1547539107, 1548166113, 1553877950, 1568593144, 1591456987, 1601245343, 1604324540, 1620824029, 1621420777, 1622659719, 1623148745, 1639293562, 1640272491, 1648581351, 1651365158, 1669413332, 1675742188, 1692511090, 1705629508, 1723805383, 1763375486, 1768164316, 1768548618, 1771130534, 1781145963, 1789423016, 1794072594, 1797611211, 1800401972, 1800886518, 1801622666, 1802291657, 1804873517, 1813879407, 1815533258, 1825405726, 1830310359, 1840455391, 1861441745, 1864494649, 1867552145, 1870897157, 1873474154, 1889717695, 1891834246, 1894671199, 1914813385, 1915412854, 1916009602, 1926178603, 1932118984, 1975830554, 1981972957, 2010580328, 2012934199, 2014410004, 2022294396, 2025055113, 2025238049, 2048392659, 2049945213, 2079583163, 2082663554, 2083500811, 2084789794, 2103468489, 2113364337, 2113708439, 2123232567, 2127021138, 2140014923, 2143813817};
		
		protected static string[] fields = new string[]{"b", "f", "h", "i", "k", "m", "q", "t", "x", "_0", "_1", "_2", "_3", "_4", "_5", "ms", "get_position", "isGlobal", "__a", "__b", "add", "arr", "cls", "cur", "dev", "dir", "eof", "ext", "get", "gid", "has", "idx", "ino", "key", "len", "map", "max", "min", "pop", "pos", "run", "set", "sub", "sum", "tbl", "uid", "first", "split", "exitCode", "teardown", "compareTo", "flags", "flush", "readAll", "match", "compare", "addSuccesses", "start", "stats", "stdin", "failures", "helper", "executeMethod", "successes", "remove", "packageName", "filter", "decodeBytes", "merge", "startTime", "progress", "hasSetup", "target", "hashCode", "testPathTo", "stderr", "stdout", "resize", "result", "warnings", "method", "matched", "addErrors", "getFullYear", "readString", "getHours", "isEmpty", "newline", "setLoop", "getString", "stackToString", "readBytes", "compareArg", "readInt16", "readInt24", "readInt32", "get_length", "mtime", "append", "onPrecheck", "setFloat", "getPackage", "assertations", "stream", "string", "_trace", "methodName", "hasErrors", "setDouble", "readUInt16", "readUInt24", "packageNames", "iterator", "indent", "toHex", "getData", "getDate", "set_position", "getUInt16", "lastIndexOf", "nbits", "writeFloat", "totals", "totlen", "testIsRelativeAndIsAbsolute", "hasNext", "onAddFailures", "setHandler", "innerError", "message", "onStart", "keysLoop", "reverse", "expireson", "nOccupied", "onTestComplete", "onAddWarnings", "getBytes", "nlink", "insert", "getInt32", "getInt64", "dumpStack", "dispatch", "length", "addSub", "getTime", "addAsync", "bigEndian", "testNormalization", "allOk", "native", "getDay", "getPid", "getMinutes", "balance", "setupName", "writeFullBytes", "matchedRight", "hasTeardownError", "nextRun", "writeString", "displaySuccessResults", "methods", "initTable", "set_bigEndian", "atime", "getClass", "encodeString", "addPackage", "getSeconds", "replace", "hours", "testToString", "onAddErrors", "setTimeout", "readDouble", "onAddSuccesses", "writeUInt16", "writeUInt24", "getDouble", "onTimeout", "value", "asyncStack", "quotient", "precheck", "aggregator", "acquire", "onTested", "addHeader", "addFailures", "compareArgs", "addBytes", "cachedIndex", "checkTested", "addInt32", "addInt64", "globalPattern", "prepare", "toString", "identity", "packages", "addWarnings", "getResults", "methodNames", "priority", "hashes", "runner", "hasAsyncError", "testDir", "testExt", "testSep", "displayHeader", "_eof", "splice", "exists", "equals", "addResult", "base", "blit", "getFixture", "addClass", "call", "copy", "bindHandler", "date", "days", "done", "matchSub", "file", "fill", "testBase", "upperMatch", "removeLoop", "minBinding", "head", "isOk", "item", "handler", "getOrCreateClass", "join", "keys", "kill", "last", "left", "list", "writeDouble", "concat", "backslash", "clear", "mode", "close", "next", "noop", "encodeBytes", "addString", "hasTestError", "testJoin", "writeByte", "flattenPackage", "pack", "path", "prev", "pure", "push", "position", "rdev", "read", "root", "matchedPos", "current", "execute", "seek", "size", "setInt32", "setInt64", "sort", "step", "stop", "quicksort", "recursive", "tell", "ctime", "readFullBytes", "vals", "writeInt8", "testRoot", "wait", "wire", "testJoinString", "completed", "values", "write", "spliceVoid", "zero", "errors", "writeBytes", "writeInput", "writeInt16", "writeInt24", "writeInt32", "cachedKey", "readFloat", "minutes", "hasTeardown", "handlers", "stackItems", "equality", "testUp", "tested", "runNext", "hasFailures", "delay", "release", "timeout", "classNames", "addFixture", "createFixture", "seconds", "hasWarnings", "concatNative", "nBuckets", "className", "hasTimeoutError", "runFixture", "onComplete", "testNormalize", "decodeString", "existsClass", "__unsafe_get", "__unsafe_set", "indents", "indexOf", "lookup", "isMethod", "fileName", "getFloat", "unbindHandler", "onProgress", "iteratorLoop", "toDynamic", "regex", "readByte", "right", "existsPackage", "classes", "__hx_constructs", "canSeek", "addDouble", "getDefault", "testToWin32ToNix", "results", "fixtures", "checkMethod", "getClassName", "teardownName", "getMonth", "unwire", "customParams", "readInt8", "getOrCreatePackage", "addEvent", "onTestStart", "hasSetupError", "readLine", "get_canSeek", "_height", "getPosition", "fixture", "__get", "__set", "testComplete", "error", "event", "lineNumber", "readUntil", "modulus", "subtract", "upperBound", "unshift", "setUInt16", "_keys", "setup", "addFloat", "shift", "matchedLeft", "__hx_createEmpty", "addByte", "addCase", "addChar", "removeMinBinding", "slice", "_handler", "complete"};
		
		protected static int length;
		
		public static void addFields(int[] nids, string[] nfields) {
			unchecked {
				int[] cids = global::haxe.lang.FieldLookup.fieldIds;
				string[] cfields = global::haxe.lang.FieldLookup.fields;
				int nlen = ( nids as global::System.Array ).Length;
				int clen = global::haxe.lang.FieldLookup.length;
				if (( ( nfields as global::System.Array ).Length != nlen )) {
					throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Different fields length: ", global::haxe.lang.Runtime.toString(nlen)), " and "), global::haxe.lang.Runtime.toString(( nfields as global::System.Array ).Length)));
				}
				
				bool needsChange = false;
				{
					int[] _g_arr = nids;
					uint _g_idx = ((uint) (0) );
					while (((bool) (( _g_idx < ( _g_arr as global::System.Array ).Length )) )) {
						if (( global::haxe.lang.FieldLookup.findHash(((int) (_g_arr[((int) (_g_idx++) )]) ), cids, clen) < 0 )) {
							needsChange = true;
							break;
						}
						
					}
					
				}
				
				if (needsChange) {
					lock(typeof(global::haxe.lang.FieldLookup)){
						int[] ansIds = new int[( clen + nlen )];
						string[] ansFields = new string[( clen + nlen )];
						int ci = 0;
						int ni = 0;
						int ansi = 0;
						while (true) {
							if ( ! ((( ( ci < clen ) && ( ni < nlen ) ))) ) {
								break;
							}
							
							if (( cids[ci] < nids[ni] )) {
								ansIds[ansi] = cids[ci];
								ansFields[ansi] = cfields[ci];
								ci = ( ci + 1 );
							}
							else {
								ansIds[ansi] = nids[ni];
								ansFields[ansi] = nfields[ni];
								ni = ( ni + 1 );
							}
							
							ansi = ( ansi + 1 );
						}
						
						if (( ci < clen )) {
							global::System.Array.Copy(((global::System.Array) (cids) ), ((int) (ci) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							global::System.Array.Copy(((global::System.Array) (cfields) ), ((int) (ci) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							ansi = ( ansi + (( clen - ci )) );
						}
						
						if (( ni < nlen )) {
							global::System.Array.Copy(((global::System.Array) (nids) ), ((int) (ni) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							global::System.Array.Copy(((global::System.Array) (nfields) ), ((int) (ni) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							ansi = ( ansi + (( nlen - ni )) );
						}
						
						global::haxe.lang.FieldLookup.fieldIds = ansIds;
						global::haxe.lang.FieldLookup.fields = ansFields;
						global::haxe.lang.FieldLookup.length = ansi;
					}
					;
				}
				
			}
		}
		
		
		public static int doHash(string s) {
			unchecked {
				int acc = 0;
				{
					int _g1 = 0;
					int _g = s.Length;
					while (( _g1 < _g )) {
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[_g1++]) ) ) << 1 );
					}
					
				}
				
				return ((int) (( ((uint) (acc) ) >> 1 )) );
			}
		}
		
		
		public static string lookupHash(int key) {
			unchecked {
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ( min + ((int) (( (( max - min )) / 2 )) ) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						return global::haxe.lang.FieldLookup.fields[mid];
					}
					
				}
				
				throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat("Field not found for hash ", global::haxe.lang.Runtime.toString(key)));
			}
		}
		
		
		public static int hash(string s) {
			unchecked {
				if (string.Equals(s, null)) {
					return 0;
				}
				
				int acc = 0;
				{
					int _g1 = 0;
					int _g = s.Length;
					while (( _g1 < _g )) {
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[_g1++]) ) ) << 1 );
					}
					
				}
				
				int key = ((int) (( ((uint) (acc) ) >> 1 )) );
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				string[] fld = global::haxe.lang.FieldLookup.fields;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				int len = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ((int) (( min + ( ((double) ((( max - min ))) ) / 2 ) )) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						if ( ! (string.Equals(fld[mid], s)) ) {
							return  ~ (key) ;
						}
						
						return key;
					}
					
				}
				
				lock(typeof(global::haxe.lang.FieldLookup)){
					if (( len != global::haxe.lang.FieldLookup.length )) {
						return global::haxe.lang.FieldLookup.hash(s);
					}
					
					global::haxe.lang.FieldLookup.insert<int>(ref global::haxe.lang.FieldLookup.fieldIds, ((int) (global::haxe.lang.FieldLookup.length) ), ((int) (min) ), ((int) (key) ));
					global::haxe.lang.FieldLookup.insert<string>(ref global::haxe.lang.FieldLookup.fields, ((int) (global::haxe.lang.FieldLookup.length) ), ((int) (min) ), ((string) (s) ));
					 ++ global::haxe.lang.FieldLookup.length;
				}
				;
				return key;
			}
		}
		
		
		public static int findHash(int hash, int[] hashs, int length) {
			unchecked {
				int min = 0;
				int max = length;
				while (( min < max )) {
					int mid = ((int) (( (( max + min )) / 2 )) );
					int imid = hashs[mid];
					if (( hash < imid )) {
						max = mid;
					}
					else if (( hash > imid )) {
						min = ( mid + 1 );
					}
					else {
						return mid;
					}
					
				}
				
				return  ~ (min) ;
			}
		}
		
		
		public static void @remove<T>(T[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = default(T);
			}
		}
		
		
		public static void insert<T>(ref T[] a, int length, int pos, T x) {
			unchecked {
				int capacity = ( a as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						T[] newarr = new T[( (( length << 1 )) + 1 )];
						( a as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a = ((T[]) (newarr) );
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						T[] newarr1 = new T[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a = ((T[]) (newarr1) );
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (a) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					T[] newarr2 = new T[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a = ((T[]) (newarr2) );
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (pos) ), ((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (a) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a[pos] = x;
			}
		}
		
		
	}
}


