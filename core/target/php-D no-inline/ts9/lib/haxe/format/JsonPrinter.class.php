<?php

// Generated by Haxe 3.3.0
class haxe_format_JsonPrinter {
	public function __construct($replacer, $space) {
		if(!php_Boot::$skip_constructor) {
		$this->replacer = $replacer;
		$this->indent = $space;
		$this->pretty = $space !== null;
		$this->nind = 0;
		$this->buf = new StringBuf();
	}}
	public $buf;
	public $replacer;
	public $indent;
	public $pretty;
	public $nind;
	public function ipad() {
		$tmp = $this->pretty;
		if($tmp) {
			$tmp1 = $this->nind * strlen($this->indent);
			$v = StringTools::lpad("", $this->indent, $tmp1);
			$this->buf->add($v);
		}
	}
	public function newl() {
		$tmp = $this->pretty;
		if($tmp) {
			$this->buf->addChar(10);
		}
	}
	public function write($k, $v) {
		if($this->replacer !== null) {
			$v = $this->replacer($k, $v);
		}
		{
			$_g = Type::typeof($v);
			switch(Type::enumIndex($_g)) {
			case 0:{
				$this->buf->add("null");
			}break;
			case 1:{
				$this->buf->add($v);
			}break;
			case 2:{
				$v1 = null;
				$tmp = Math::isFinite($v);
				if($tmp) {
					$v1 = $v;
				} else {
					$v1 = "null";
				}
				$this->buf->add($v1);
			}break;
			case 3:{
				$tmp1 = null;
				if($v) {
					$tmp1 = "true";
				} else {
					$tmp1 = "false";
				}
				$this->buf->add($tmp1);
			}break;
			case 4:{
				$this->objString($v);
			}break;
			case 5:{
				$this->buf->add("\"<fun>\"");
			}break;
			case 6:{
				$c = _hx_deref($_g)->params[0];
				if((is_object($_t = $c) && ($_t instanceof Enum) ? $_t == _hx_qtype("String") : _hx_equal($_t, _hx_qtype("String")))) {
					$this->quote($v);
				} else {
					if((is_object($_t2 = $c) && ($_t2 instanceof Enum) ? $_t2 == _hx_qtype("Array") : _hx_equal($_t2, _hx_qtype("Array")))) {
						$v2 = $v;
						$this->buf->addChar(91);
						$len = $v2->length;
						$last = $len - 1;
						{
							$_g1 = 0;
							while($_g1 < $len) {
								$i = $_g1++;
								if($i > 0) {
									$this->buf->addChar(44);
								} else {
									$this->nind++;
								}
								$this->newl();
								$this->ipad();
								$this->write($i, $v2[$i]);
								if($i === $last) {
									$this->nind--;
									$this->newl();
									$this->ipad();
								}
								unset($i);
							}
						}
						$this->buf->addChar(93);
					} else {
						if((is_object($_t3 = $c) && ($_t3 instanceof Enum) ? $_t3 == _hx_qtype("haxe.ds.StringMap") : _hx_equal($_t3, _hx_qtype("haxe.ds.StringMap")))) {
							$v3 = $v;
							$o = _hx_anonymous(array());
							{
								$tmp2 = $v3->keys();
								while(true) {
									$tmp3 = !$tmp2->hasNext();
									if($tmp3) {
										break;
									}
									$k1 = $tmp2->next();
									$tmp4 = $v3->get($k1);
									Reflect::setField($o, $k1, $tmp4);
									unset($tmp4,$tmp3,$k1);
								}
							}
							$this->objString($o);
						} else {
							if((is_object($_t4 = $c) && ($_t4 instanceof Enum) ? $_t4 == _hx_qtype("Date") : _hx_equal($_t4, _hx_qtype("Date")))) {
								$v4 = $v;
								$tmp5 = $v4->toString();
								$this->quote($tmp5);
							} else {
								$this->objString($v);
							}
						}
					}
				}
			}break;
			case 7:{
				$i1 = Type::enumIndex($v);
				$this->buf->add($i1);
			}break;
			case 8:{
				$this->buf->add("\"???\"");
			}break;
			}
		}
	}
	public function objString($v) {
		$tmp = Reflect::fields($v);
		$this->fieldsString($v, $tmp);
	}
	public function fieldsString($v, $fields) {
		$this->buf->addChar(123);
		$len = $fields->length;
		$last = $len - 1;
		$first = true;
		{
			$_g1 = 0;
			while($_g1 < $len) {
				$i = $_g1++;
				$f = $fields[$i];
				$value = Reflect::field($v, $f);
				$tmp = Reflect::isFunction($value);
				if($tmp) {
					continue;
				}
				if($first) {
					$this->nind++;
					$first = false;
				} else {
					$this->buf->addChar(44);
				}
				$this->newl();
				$this->ipad();
				$this->quote($f);
				$this->buf->addChar(58);
				$tmp1 = $this->pretty;
				if($tmp1) {
					$this->buf->addChar(32);
				}
				$this->write($f, $value);
				if($i === $last) {
					$this->nind--;
					$this->newl();
					$this->ipad();
				}
				unset($value,$tmp1,$tmp,$i,$f);
			}
		}
		$this->buf->addChar(125);
	}
	public function quote($s) {
		$tmp = strlen($s);
		$tmp1 = haxe_Utf8::length($s);
		if($tmp !== $tmp1) {
			$this->quoteUtf8($s);
			return;
		}
		$this->buf->addChar(34);
		$i = 0;
		while(true) {
			$tmp2 = $i++;
			$c = StringTools::fastCodeAt($s, $tmp2);
			$tmp3 = StringTools::isEof($c);
			if($tmp3) {
				break;
			}
			switch($c) {
			case 8:{
				$this->buf->add("\\b");
			}break;
			case 9:{
				$this->buf->add("\\t");
			}break;
			case 10:{
				$this->buf->add("\\n");
			}break;
			case 12:{
				$this->buf->add("\\f");
			}break;
			case 13:{
				$this->buf->add("\\r");
			}break;
			case 34:{
				$this->buf->add("\\\"");
			}break;
			case 92:{
				$this->buf->add("\\\\");
			}break;
			default:{
				$this->buf->addChar($c);
			}break;
			}
			unset($tmp3,$tmp2,$c);
		}
		$this->buf->addChar(34);
	}
	public function quoteUtf8($s) {
		$u = new haxe_Utf8(null);
		haxe_Utf8::iter($s, array(new _hx_lambda(array(&$u), "haxe_format_JsonPrinter_0"), 'execute'));
		$this->buf->add("\"");
		$tmp = $u->toString();
		$this->buf->add($tmp);
		$this->buf->add("\"");
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function hprint($o, $replacer = null, $space = null) {
		$printer = new haxe_format_JsonPrinter($replacer, $space);
		$printer->write("", $o);
		return $printer->buf->toString();
	}
	function __toString() { return 'haxe.format.JsonPrinter'; }
}
function haxe_format_JsonPrinter_0(&$u, $c) {
	{
		switch($c) {
		case 8:{
			$u->addChar(92);
			$u->addChar(98);
		}break;
		case 9:{
			$u->addChar(92);
			$u->addChar(116);
		}break;
		case 10:{
			$u->addChar(92);
			$u->addChar(110);
		}break;
		case 12:{
			$u->addChar(92);
			$u->addChar(102);
		}break;
		case 13:{
			$u->addChar(92);
			$u->addChar(114);
		}break;
		case 34:case 92:{
			$u->addChar(92);
			$u->addChar($c);
		}break;
		default:{
			$u->addChar($c);
		}break;
		}
	}
}
