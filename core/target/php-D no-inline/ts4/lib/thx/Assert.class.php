<?php

// Generated by Haxe 3.3.0
class thx_Assert {
	public function __construct(){}
	static $behavior;
	static function contains($possibilities, $value, $msg = null, $pos = null) {
		$tmp = thx_Arrays::contains($possibilities, $value, null);
		if($tmp) {
			thx_Assert::pass($msg, $pos);
		} else {
			$tmp1 = null;
			if($msg === null) {
				$tmp2 = Std::string($value);
				$tmp3 = "value " . _hx_string_or_null($tmp2) . " not found in the expected possibilities ";
				$tmp4 = Std::string($possibilities);
				$tmp1 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
			} else {
				$tmp1 = $msg;
			}
			thx_Assert::fail($tmp1, $pos);
		}
	}
	static function equals($expected, $value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = Std::string($expected);
			$tmp1 = "expected " . _hx_string_or_null($tmp) . " but it is ";
			$tmp2 = Std::string($value);
			$msg = _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2);
		}
		thx_Assert::isTrue(_hx_equal($expected, $value), $msg, $pos);
	}
	static function excludes($match, $values, $msg = null, $pos = null) {
		$tmp = !thx_Arrays::contains($values, $match, null);
		if($tmp) {
			thx_Assert::pass($msg, $pos);
		} else {
			$tmp1 = null;
			if($msg === null) {
				$tmp2 = Std::string($values);
				$tmp3 = "values " . _hx_string_or_null($tmp2) . " do contain ";
				$tmp4 = Std::string($match);
				$tmp1 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
			} else {
				$tmp1 = $msg;
			}
			thx_Assert::fail($tmp1, $pos);
		}
	}
	static function fail($msg = null, $pos = null) {
		if($msg === null) {
			$msg = "failure expected";
		}
		thx_Assert::isTrue(false, $msg, $pos);
	}
	static function isContainedIn($match, $values, $msg = null, $pos = null) {
		$tmp = thx_Arrays::contains($values, $match, null);
		if($tmp) {
			thx_Assert::pass($msg, $pos);
		} else {
			$tmp1 = null;
			if($msg === null) {
				$tmp2 = Std::string($values);
				$tmp3 = "values " . _hx_string_or_null($tmp2) . " do not contain ";
				$tmp4 = Std::string($match);
				$tmp1 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
			} else {
				$tmp1 = $msg;
			}
			thx_Assert::fail($tmp1, $pos);
		}
	}
	static function isFalse($value, $msg = null, $pos = null) {
		$tmp = null === $msg;
		if($tmp) {
			$msg = "expected false";
		}
		thx_Assert::isTrue($value === false, $msg, $pos);
	}
	static function is($value, $type, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = thx_Types::anyValueToString($type);
			$tmp1 = "expected type " . _hx_string_or_null($tmp) . " but it is ";
			$tmp2 = thx_Types::valueTypeToString($value);
			$msg = _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2);
		}
		$tmp3 = Std::is($value, $type);
		thx_Assert::isTrue($tmp3, $msg, $pos);
	}
	static function isNull($value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = Std::string($value);
			$msg = "expected null but it is " . _hx_string_or_null($tmp);
		}
		thx_Assert::isTrue($value === null, $msg, $pos);
	}
	static function isTrue($cond, $msg = null, $pos = null) {
		if($cond) {
			thx_Assert::$behavior->success($pos);
		} else {
			thx_Assert::$behavior->fail($msg, $pos);
		}
	}
	static function matches($pattern, $value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = Std::string($value);
			$msg = "the value " . _hx_string_or_null($tmp) . " does not match the provided pattern";
		}
		$tmp1 = $pattern->match($value);
		thx_Assert::isTrue($tmp1, $msg, $pos);
	}
	static function nearEquals($expected, $value, $approx = null, $msg = null, $pos = null) {
		$tmp = $msg === null;
		if($tmp) {
			$msg = "expected " . _hx_string_rec($expected, "") . " but it is " . _hx_string_rec($value, "");
		}
		$tmp1 = thx_Floats::nearEquals($expected, $value, $approx);
		thx_Assert::isTrue($tmp1, $msg, $pos);
		return;
	}
	static function notEquals($expected, $value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = Std::string($expected);
			$tmp1 = "expected " . _hx_string_or_null($tmp) . " and test value ";
			$tmp2 = Std::string($value);
			$msg = _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2) . " should be different";
		}
		thx_Assert::isFalse(_hx_equal($expected, $value), $msg, $pos);
	}
	static function notNull($value, $msg = null, $pos = null) {
		$tmp = null === $msg;
		if($tmp) {
			$msg = "expected not null";
		}
		thx_Assert::isTrue($value !== null, $msg, $pos);
	}
	static function pass($msg = null, $pos = null) {
		if($msg === null) {
			$msg = "pass expected";
		}
		thx_Assert::isTrue(true, $msg, $pos);
	}
	static function raises($method, $type = null, $msgNotThrown = null, $msgWrongType = null, $pos = null) {
		try {
			call_user_func($method);
			if(null === $msgNotThrown) {
				$name = null;
				if(null === $type) {
					$name = "Dynamic";
				} else {
					$name = thx_Types::anyValueToString($type);
				}
				$msgNotThrown = "exception of type " . _hx_string_or_null($name) . " not raised";
			}
			thx_Assert::fail($msgNotThrown, $pos);
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$ex = $_ex_;
			{
				if(null === $type) {
					thx_Assert::pass(null, $pos);
				} else {
					if(null === $msgWrongType) {
						$name1 = thx_Types::anyValueToString($type);
						$tmp = "expected throw of type " . _hx_string_or_null($name1) . " but it is ";
						$tmp1 = Std::string($ex);
						$msgWrongType = _hx_string_or_null($tmp) . _hx_string_or_null($tmp1);
					}
					$tmp2 = Std::is($ex, $type);
					thx_Assert::isTrue($tmp2, $msgWrongType, $pos);
				}
			}
		}
	}
	static function same($expected, $value, $recursive = null, $msg = null, $pos = null) {
		if($recursive === null) {
			$recursive = true;
		}
		$status = _hx_anonymous(array("recursive" => $recursive, "path" => "", "error" => null));
		$tmp = thx_Assert::sameAs($expected, $value, $status);
		if($tmp) {
			thx_Assert::pass($msg, $pos);
		} else {
			$tmp1 = null;
			if($msg === null) {
				$tmp1 = $status->error;
			} else {
				$tmp1 = $msg;
			}
			thx_Assert::fail($tmp1, $pos);
		}
	}
	static function stringContains($match, $value, $msg = null, $pos = null) {
		$tmp = null;
		if($value !== null) {
			$tmp1 = _hx_index_of($value, $match, null);
			$tmp = $tmp1 >= 0;
		} else {
			$tmp = false;
		}
		if($tmp) {
			thx_Assert::pass($msg, $pos);
		} else {
			$tmp2 = null;
			if($msg === null) {
				$tmp3 = thx_Strings::quote($value);
				$tmp4 = "value " . _hx_string_or_null($tmp3) . " does not contain ";
				$tmp5 = thx_Strings::quote($match);
				$tmp2 = _hx_string_or_null($tmp4) . _hx_string_or_null($tmp5);
			} else {
				$tmp2 = $msg;
			}
			thx_Assert::fail($tmp2, $pos);
		}
	}
	static function stringSequence($sequence, $value, $msg = null, $pos = null) {
		if(null === $value) {
			$tmp = null;
			if($msg === null) {
				$tmp = "null argument value";
			} else {
				$tmp = $msg;
			}
			thx_Assert::fail($tmp, $pos);
			return;
		}
		$p = 0;
		{
			$_g = 0;
			while($_g < $sequence->length) {
				$s = $sequence[$_g];
				++$_g;
				$p2 = _hx_index_of($value, $s, $p);
				if($p2 < 0) {
					if($msg === null) {
						$tmp1 = thx_Strings::quote($s);
						$msg = "expected " . _hx_string_or_null($tmp1) . " after ";
						if($p > 0) {
							$tmp2 = thx_Strings::ellipsis($value, 30, null);
							$tmp3 = thx_Strings::quote($tmp2);
							$msg .= " " . _hx_string_or_null($tmp3);
							unset($tmp3,$tmp2);
						} else {
							$msg .= " begin";
						}
						unset($tmp1);
					}
					thx_Assert::fail($msg, $pos);
					return;
				}
				$p = $p2 + strlen($s);
				unset($s,$p2);
			}
		}
		thx_Assert::pass($msg, $pos);
	}
	static function warn($msg, $pos = null) {
		thx_Assert::$behavior->warn($msg, $pos);
	}
	static function sameAs($expected, $value, $status) {
		$withPath = array(new _hx_lambda(array(&$status), "thx_Assert_0"), 'execute');
		$tmp1 = !thx_Types::sameType($expected, $value);
		if($tmp1) {
			$texpected = thx_Types::valueTypeToString($expected);
			$tvalue = thx_Types::valueTypeToString($value);
			$status->error = call_user_func_array($withPath, array("expected type " . _hx_string_or_null($texpected) . " but it is " . _hx_string_or_null($tvalue)));
			return false;
		}
		$_g = Type::typeof($expected);
		switch(Type::enumIndex($_g)) {
		case 0:case 1:case 3:{
			if(!_hx_equal($expected, $value)) {
				$tmp2 = Std::string($expected);
				$tmp3 = "expected " . _hx_string_or_null($tmp2) . " but it is ";
				$tmp4 = Std::string($value);
				$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp3) . _hx_string_or_null($tmp4)));
				return false;
			}
			return true;
		}break;
		case 2:{
			$tmp5 = !thx_Floats::nearEquals($expected, $value, null);
			if($tmp5) {
				$tmp6 = Std::string($expected);
				$tmp7 = "expected " . _hx_string_or_null($tmp6) . " but it is ";
				$tmp8 = Std::string($value);
				$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp7) . _hx_string_or_null($tmp8)));
				return false;
			}
			return true;
		}break;
		case 4:{
			$tmp9 = null;
			if(!$status->recursive) {
				$tmp9 = $status->path === "";
			} else {
				$tmp9 = true;
			}
			if($tmp9) {
				$tfields = Reflect::fields($value);
				$fields = Reflect::fields($expected);
				$path = $status->path;
				{
					$_g1 = 0;
					while($_g1 < $fields->length) {
						$field = $fields[$_g1];
						++$_g1;
						$tfields->remove($field);
						$tmp10 = null;
						if($path === "") {
							$tmp10 = $field;
						} else {
							$tmp10 = "" . _hx_string_or_null($path) . "." . _hx_string_or_null($field);
						}
						$status->path = $tmp10;
						$tmp11 = !Reflect::hasField($value, $field);
						if($tmp11) {
							$tmp12 = "expected field " . _hx_string_or_null($status->path) . " does not exist in ";
							$tmp13 = Std::string($value);
							$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp12) . _hx_string_or_null($tmp13)));
							return false;
							unset($tmp13,$tmp12);
						}
						$e = Reflect::field($expected, $field);
						$tmp14 = Reflect::isFunction($e);
						if($tmp14) {
							continue;
						}
						$v = Reflect::field($value, $field);
						$tmp15 = !thx_Assert::sameAs($e, $v, $status);
						if($tmp15) {
							return false;
						}
						unset($v,$tmp15,$tmp14,$tmp11,$tmp10,$field,$e);
					}
				}
				$tmp16 = $tfields->length > 0;
				if($tmp16) {
					$tmp17 = $tfields->join(", ");
					$status->error = call_user_func_array($withPath, array("the tested object has extra field(s) (" . _hx_string_or_null($tmp17) . ") not included in the expected ones"));
					return false;
				}
			}
			$tmp18 = thx_Iterators::isIterator($expected);
			if($tmp18) {
				$tmp19 = !thx_Iterators::isIterator($value);
				if($tmp19) {
					$status->error = call_user_func_array($withPath, array("expected an Iterable"));
					return false;
				}
				$tmp20 = null;
				if(!$status->recursive) {
					$tmp20 = $status->path === "";
				} else {
					$tmp20 = true;
				}
				if($tmp20) {
					$evalues = thx_Iterators::toArray($expected);
					$vvalues = thx_Iterators::toArray($value);
					$tmp21 = $evalues->length !== $vvalues->length;
					if($tmp21) {
						$tmp22 = "expected " . _hx_string_rec($evalues->length, "") . " values in Iterator but they are " . _hx_string_rec($vvalues->length, "");
						$status->error = call_user_func_array($withPath, array($tmp22));
						return false;
					}
					$path1 = $status->path;
					{
						$_g11 = 0;
						$_g2 = $evalues->length;
						while($_g11 < $_g2) {
							$i = $_g11++;
							$tmp23 = null;
							if($path1 === "") {
								$tmp23 = "iterator[" . _hx_string_rec($i, "") . "]";
							} else {
								$tmp23 = _hx_string_or_null($path1) . _hx_string_or_null(("[" . _hx_string_rec($i, "") . "]"));
							}
							$status->path = $tmp23;
							$tmp24 = !thx_Assert::sameAs($evalues[$i], $vvalues[$i], $status);
							if($tmp24) {
								$tmp25 = Std::string($expected);
								$tmp26 = "expected " . _hx_string_or_null($tmp25) . " but it is ";
								$tmp27 = Std::string($value);
								$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp26) . _hx_string_or_null($tmp27)));
								return false;
								unset($tmp27,$tmp26,$tmp25);
							}
							unset($tmp24,$tmp23,$i);
						}
					}
				}
				return true;
			}
			$tmp28 = thx_Iterables::isIterable($expected);
			if($tmp28) {
				$tmp29 = !thx_Iterables::isIterable($value);
				if($tmp29) {
					$status->error = call_user_func_array($withPath, array("expected an Iterator"));
					return false;
				}
				$tmp30 = null;
				if(!$status->recursive) {
					$tmp30 = $status->path === "";
				} else {
					$tmp30 = true;
				}
				if($tmp30) {
					$evalues1 = thx_Iterables::toArray($expected);
					$vvalues1 = thx_Iterables::toArray($value);
					$tmp31 = $evalues1->length !== $vvalues1->length;
					if($tmp31) {
						$tmp32 = "expected " . _hx_string_rec($evalues1->length, "") . " values in Iterable but they are " . _hx_string_rec($vvalues1->length, "");
						$status->error = call_user_func_array($withPath, array($tmp32));
						return false;
					}
					$path2 = $status->path;
					{
						$_g12 = 0;
						$_g3 = $evalues1->length;
						while($_g12 < $_g3) {
							$i1 = $_g12++;
							$tmp33 = null;
							if($path2 === "") {
								$tmp33 = "iterable[" . _hx_string_rec($i1, "") . "]";
							} else {
								$tmp33 = _hx_string_or_null($path2) . _hx_string_or_null(("[" . _hx_string_rec($i1, "") . "]"));
							}
							$status->path = $tmp33;
							$tmp34 = !thx_Assert::sameAs($evalues1[$i1], $vvalues1[$i1], $status);
							if($tmp34) {
								return false;
							}
							unset($tmp34,$tmp33,$i1);
						}
					}
				}
				return true;
			}
			return true;
		}break;
		case 5:{
			$tmp35 = !Reflect::compareMethods($expected, $value);
			if($tmp35) {
				$status->error = call_user_func_array($withPath, array("expected same function reference"));
				return false;
			}
			return true;
		}break;
		case 6:{
			$tmp36 = null;
			$tmp37 = Std::is($expected, _hx_qtype("String"));
			if($tmp37) {
				$tmp36 = !_hx_equal($expected, $value);
			} else {
				$tmp36 = false;
			}
			if($tmp36) {
				$tmp38 = thx_Strings::quote($expected);
				$tmp39 = "expected " . _hx_string_or_null($tmp38) . " but it is ";
				$tmp40 = thx_Strings::quote($value);
				$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp39) . _hx_string_or_null($tmp40)));
				return false;
			}
			$tmp41 = Std::is($expected, _hx_qtype("Array"));
			if($tmp41) {
				$tmp42 = null;
				if(!$status->recursive) {
					$tmp42 = $status->path === "";
				} else {
					$tmp42 = true;
				}
				if($tmp42) {
					$tmp43 = !_hx_equal(_hx_len($expected), _hx_len($value));
					if($tmp43) {
						$tmp44 = Std::string(_hx_len($expected));
						$tmp45 = "expected " . _hx_string_or_null($tmp44) . " elements but they are ";
						$tmp46 = Std::string(_hx_len($value));
						$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp45) . _hx_string_or_null($tmp46)));
						return false;
					}
					$path3 = $status->path;
					{
						$_g13 = 0;
						$_g4 = _hx_len($expected);
						while($_g13 < $_g4) {
							$i2 = $_g13++;
							$tmp47 = null;
							if($path3 === "") {
								$tmp47 = "array[" . _hx_string_rec($i2, "") . "]";
							} else {
								$tmp47 = _hx_string_or_null($path3) . _hx_string_or_null(("[" . _hx_string_rec($i2, "") . "]"));
							}
							$status->path = $tmp47;
							$tmp48 = !thx_Assert::sameAs($expected[$i2], $value[$i2], $status);
							if($tmp48) {
								$tmp49 = Std::string($expected[$i2]);
								$tmp50 = "expected " . _hx_string_or_null($tmp49) . " but it is ";
								$tmp51 = Std::string($value[$i2]);
								$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp50) . _hx_string_or_null($tmp51)));
								return false;
								unset($tmp51,$tmp50,$tmp49);
							}
							unset($tmp48,$tmp47,$i2);
						}
					}
				}
				return true;
			}
			$tmp52 = Std::is($expected, _hx_qtype("Date"));
			if($tmp52) {
				$tmp53 = $expected->getTime();
				$tmp54 = $value->getTime();
				if($tmp53 !== $tmp54) {
					$tmp55 = Std::string($expected);
					$tmp56 = "expected " . _hx_string_or_null($tmp55) . " but it is ";
					$tmp57 = Std::string($value);
					$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp56) . _hx_string_or_null($tmp57)));
					return false;
				}
				return true;
			}
			$tmp58 = Std::is($expected, _hx_qtype("haxe.io.Bytes"));
			if($tmp58) {
				$tmp59 = null;
				if(!$status->recursive) {
					$tmp59 = $status->path === "";
				} else {
					$tmp59 = true;
				}
				if($tmp59) {
					$ebytes = $expected;
					$vbytes = $value;
					if($ebytes->length !== $vbytes->length) {
						return false;
					}
					{
						$_g14 = 0;
						$_g5 = $ebytes->length;
						while($_g14 < $_g5) {
							$i3 = $_g14++;
							$tmp60 = $ebytes->get($i3);
							$tmp61 = $vbytes->get($i3);
							if($tmp60 !== $tmp61) {
								$tmp62 = $ebytes->get($i3);
								$tmp63 = "expected byte " . _hx_string_rec($tmp62, "") . " but it is ";
								$tmp64 = $vbytes->get($i3);
								$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp63) . _hx_string_rec($tmp64, "")));
								return false;
								unset($tmp64,$tmp63,$tmp62);
							}
							unset($tmp61,$tmp60,$i3);
						}
					}
				}
				return true;
			}
			$tmp65 = Std::is($expected, _hx_qtype("haxe.IMap"));
			if($tmp65) {
				$tmp66 = null;
				if(!$status->recursive) {
					$tmp66 = $status->path === "";
				} else {
					$tmp66 = true;
				}
				if($tmp66) {
					$map = $expected;
					$vmap = $value;
					$_g6 = (new _hx_array(array()));
					{
						$tmp67 = $map->keys();
						while(true) {
							$tmp68 = !$tmp67->hasNext();
							if($tmp68) {
								break;
							}
							$k = $tmp67->next();
							$_g6->push($k);
							unset($tmp68,$k);
						}
					}
					$_g15 = (new _hx_array(array()));
					{
						$tmp69 = $vmap->keys();
						while(true) {
							$tmp70 = !$tmp69->hasNext();
							if($tmp70) {
								break;
							}
							$k1 = $tmp69->next();
							$_g15->push($k1);
							unset($tmp70,$k1);
						}
					}
					$tmp71 = $_g6->length !== $_g15->length;
					if($tmp71) {
						$tmp72 = "expected " . _hx_string_rec($_g6->length, "") . " keys but they are " . _hx_string_rec($_g15->length, "");
						$status->error = call_user_func_array($withPath, array($tmp72));
						return false;
					}
					$path4 = $status->path;
					{
						$_g21 = 0;
						while($_g21 < $_g6->length) {
							$key = $_g6[$_g21];
							++$_g21;
							$tmp73 = null;
							if($path4 === "") {
								$tmp74 = Std::string($key);
								$tmp73 = "hash[" . _hx_string_or_null($tmp74) . "]";
								unset($tmp74);
							} else {
								$tmp75 = Std::string($key);
								$tmp73 = _hx_string_or_null($path4) . _hx_string_or_null(("[" . _hx_string_or_null($tmp75) . "]"));
								unset($tmp75);
							}
							$status->path = $tmp73;
							$tmp76 = $map->get($key);
							$tmp77 = $vmap->get($key);
							$tmp78 = !thx_Assert::sameAs($tmp76, $tmp77, $status);
							if($tmp78) {
								$tmp79 = Std::string($expected);
								$tmp80 = "expected " . _hx_string_or_null($tmp79) . " but it is ";
								$tmp81 = Std::string($value);
								$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp80) . _hx_string_or_null($tmp81)));
								return false;
								unset($tmp81,$tmp80,$tmp79);
							}
							unset($tmp78,$tmp77,$tmp76,$tmp73,$key);
						}
					}
				}
				return true;
			}
			$tmp82 = thx_Iterators::isIterator($expected);
			if($tmp82) {
				$tmp83 = null;
				if(!$status->recursive) {
					$tmp83 = $status->path === "";
				} else {
					$tmp83 = true;
				}
				if($tmp83) {
					$evalues2 = thx_Iterators::toArray($expected);
					$vvalues2 = thx_Iterators::toArray($value);
					$tmp84 = $evalues2->length !== $vvalues2->length;
					if($tmp84) {
						$tmp85 = "expected " . _hx_string_rec($evalues2->length, "") . " values in Iterator but they are " . _hx_string_rec($vvalues2->length, "");
						$status->error = call_user_func_array($withPath, array($tmp85));
						return false;
					}
					$path5 = $status->path;
					{
						$_g16 = 0;
						$_g7 = $evalues2->length;
						while($_g16 < $_g7) {
							$i4 = $_g16++;
							$tmp86 = null;
							if($path5 === "") {
								$tmp86 = "iterator[" . _hx_string_rec($i4, "") . "]";
							} else {
								$tmp86 = _hx_string_or_null($path5) . _hx_string_or_null(("" . _hx_string_or_null($path5) . "[" . _hx_string_rec($i4, "") . "]"));
							}
							$status->path = $tmp86;
							$tmp87 = !thx_Assert::sameAs($evalues2[$i4], $vvalues2[$i4], $status);
							if($tmp87) {
								$tmp88 = Std::string($expected);
								$tmp89 = "expected " . _hx_string_or_null($tmp88) . " but it is ";
								$tmp90 = Std::string($value);
								$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp89) . _hx_string_or_null($tmp90)));
								return false;
								unset($tmp90,$tmp89,$tmp88);
							}
							unset($tmp87,$tmp86,$i4);
						}
					}
				}
				return true;
			}
			$tmp91 = thx_Iterables::isIterable($expected);
			if($tmp91) {
				$tmp92 = null;
				if(!$status->recursive) {
					$tmp92 = $status->path === "";
				} else {
					$tmp92 = true;
				}
				if($tmp92) {
					$evalues3 = thx_Iterables::toArray($expected);
					$vvalues3 = thx_Iterables::toArray($value);
					$tmp93 = $evalues3->length !== $vvalues3->length;
					if($tmp93) {
						$tmp94 = "expected " . _hx_string_rec($evalues3->length, "") . " values in Iterable but they are " . _hx_string_rec($vvalues3->length, "");
						$status->error = call_user_func_array($withPath, array($tmp94));
						return false;
					}
					$path6 = $status->path;
					{
						$_g17 = 0;
						$_g8 = $evalues3->length;
						while($_g17 < $_g8) {
							$i5 = $_g17++;
							$tmp95 = null;
							if($path6 === "") {
								$tmp95 = "iterable[" . _hx_string_rec($i5, "") . "]";
							} else {
								$tmp95 = _hx_string_or_null($path6) . _hx_string_or_null(("[" . _hx_string_rec($i5, "") . "]"));
							}
							$status->path = $tmp95;
							$tmp96 = !thx_Assert::sameAs($evalues3[$i5], $vvalues3[$i5], $status);
							if($tmp96) {
								return false;
							}
							unset($tmp96,$tmp95,$i5);
						}
					}
				}
				return true;
			}
			$tmp97 = null;
			if(!$status->recursive) {
				$tmp97 = $status->path === "";
			} else {
				$tmp97 = true;
			}
			if($tmp97) {
				$tmp98 = Type::getClass($expected);
				$fields1 = Type::getInstanceFields($tmp98);
				$path7 = $status->path;
				{
					$_g9 = 0;
					while($_g9 < $fields1->length) {
						$field1 = $fields1[$_g9];
						++$_g9;
						$tmp99 = null;
						if($path7 === "") {
							$tmp99 = $field1;
						} else {
							$tmp99 = "" . _hx_string_or_null($path7) . "." . _hx_string_or_null($field1);
						}
						$status->path = $tmp99;
						$e1 = Reflect::field($expected, $field1);
						$tmp100 = Reflect::isFunction($e1);
						if($tmp100) {
							continue;
						}
						$v1 = Reflect::field($value, $field1);
						$tmp101 = !thx_Assert::sameAs($e1, $v1, $status);
						if($tmp101) {
							return false;
						}
						unset($v1,$tmp99,$tmp101,$tmp100,$field1,$e1);
					}
				}
			}
			return true;
		}break;
		case 7:{
			$eexpected = Type::getEnumName(_hx_deref($_g)->params[0]);
			$tmp102 = Type::getEnum($value);
			$evalue = Type::getEnumName($tmp102);
			if($eexpected !== $evalue) {
				$status->error = call_user_func_array($withPath, array("expected enumeration of " . _hx_string_or_null($eexpected) . " but it is " . _hx_string_or_null($evalue)));
				return false;
			}
			$tmp103 = null;
			if(!$status->recursive) {
				$tmp103 = $status->path === "";
			} else {
				$tmp103 = true;
			}
			if($tmp103) {
				if(Type::enumIndex($expected) !== Type::enumIndex($value)) {
					$status->error = call_user_func_array($withPath, array("expected " . _hx_string_or_null(Type::enumConstructor($expected)) . " but it is " . _hx_string_or_null(Type::enumConstructor($value))));
					return false;
				}
				$eparams = Type::enumParameters($expected);
				$vparams = Type::enumParameters($value);
				$path8 = $status->path;
				{
					$_g18 = 0;
					$_g10 = $eparams->length;
					while($_g18 < $_g10) {
						$i6 = $_g18++;
						$tmp104 = null;
						if($path8 === "") {
							$tmp104 = "enum[" . _hx_string_rec($i6, "") . "]";
						} else {
							$tmp104 = _hx_string_or_null($path8) . _hx_string_or_null(("[" . _hx_string_rec($i6, "") . "]"));
						}
						$status->path = $tmp104;
						$tmp105 = !thx_Assert::sameAs($eparams[$i6], $vparams[$i6], $status);
						if($tmp105) {
							$tmp106 = Std::string($expected);
							$tmp107 = "expected " . _hx_string_or_null($tmp106) . " but it is ";
							$tmp108 = Std::string($value);
							$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp107) . _hx_string_or_null($tmp108)));
							return false;
							unset($tmp108,$tmp107,$tmp106);
						}
						unset($tmp105,$tmp104,$i6);
					}
				}
			}
			return true;
		}break;
		case 8:{
			throw new HException("Unable to compare two unknown types");
		}break;
		}
	}
	function __toString() { return 'thx.Assert'; }
}
thx_Assert::$behavior = new thx_DefaultAssertBehavior();
function thx_Assert_0(&$status, $msg) {
	{
		$tmp = null;
		if(thx_Strings::isEmpty($status->path)) {
			$tmp = "";
		} else {
			$tmp = " at " . _hx_string_or_null($status->path);
		}
		return _hx_string_or_null($msg) . _hx_string_or_null($tmp);
	}
}
