<?php

// Generated by Haxe 3.3.0
class thx_Options {
	public function __construct(){}
	static function ofValue($value) {
		if(null === $value) {
			return haxe_ds_Option::$None;
		} else {
			return haxe_ds_Option::Some($value);
		}
	}
	static function maybe($value) {
		if(null === $value) {
			return haxe_ds_Option::$None;
		} else {
			return haxe_ds_Option::Some($value);
		}
	}
	static function equals($a, $b, $eq = null) {
		switch(Type::enumIndex($a)) {
		case 0:{
			if(Type::enumIndex($b) === 0) {
				$a1 = _hx_deref($a)->params[0];
				$b1 = _hx_deref($b)->params[0];
				$tmp = null === $eq;
				if($tmp) {
					$eq = array(new _hx_lambda(array(), "thx_Options_0"), 'execute');
				}
				return call_user_func_array($eq, array($a1, $b1));
			} else {
				return false;
			}
		}break;
		case 1:{
			if(Type::enumIndex($b) === 1) {
				return true;
			} else {
				return false;
			}
		}break;
		}
	}
	static function equalsValue($a, $b, $eq = null) {
		$tmp = thx_Options::toOption($b);
		return thx_Options::equals($a, $tmp, $eq);
	}
	static function map($option, $callback) {
		switch(Type::enumIndex($option)) {
		case 0:{
			$tmp = call_user_func_array($callback, array(_hx_deref($option)->params[0]));
			return haxe_ds_Option::Some($tmp);
		}break;
		case 1:{
			return haxe_ds_Option::$None;
		}break;
		}
	}
	static function ap($option, $fopt) {
		switch(Type::enumIndex($option)) {
		case 0:{
			$v = _hx_deref($option)->params[0];
			return thx_Options::map($fopt, array(new _hx_lambda(array(&$v), "thx_Options_1"), 'execute'));
		}break;
		case 1:{
			return haxe_ds_Option::$None;
		}break;
		}
	}
	static function flatMap($option, $callback) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return call_user_func_array($callback, array(_hx_deref($option)->params[0]));
		}break;
		case 1:{
			return haxe_ds_Option::$None;
		}break;
		}
	}
	static function join($option) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return _hx_deref($option)->params[0];
		}break;
		case 1:{
			return haxe_ds_Option::$None;
		}break;
		}
	}
	static function cata($option, $ifNone, $f) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return call_user_func_array($f, array(_hx_deref($option)->params[0]));
		}break;
		case 1:{
			return $ifNone;
		}break;
		}
	}
	static function foldLeft($option, $b, $f) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return call_user_func_array($f, array($b, _hx_deref($option)->params[0]));
		}break;
		case 1:{
			return $b;
		}break;
		}
	}
	static function foldMap($option, $f, $m) {
		$tmp = thx_Options::map($option, $f);
		$tmp1 = thx__Monoid_Monoid_Impl_::get_zero($m);
		$_e = $m;
		$tmp2 = array(new _hx_lambda(array(&$_e), "thx_Options_2"), 'execute');
		return thx_Options::foldLeft($tmp, $tmp1, $tmp2);
	}
	static function filter($option, $f) {
		if(Type::enumIndex($option) === 0) {
			$tmp = call_user_func_array($f, array(_hx_deref($option)->params[0]));
			if($tmp) {
				return $option;
			} else {
				return haxe_ds_Option::$None;
			}
		} else {
			return haxe_ds_Option::$None;
		}
	}
	static function toArray($option) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return (new _hx_array(array(_hx_deref($option)->params[0])));
		}break;
		case 1:{
			return (new _hx_array(array()));
		}break;
		}
	}
	static function toBool($option) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return true;
		}break;
		case 1:{
			return false;
		}break;
		}
	}
	static function isNone($option) {
		return !thx_Options::toBool($option);
	}
	static function toOption($value) {
		if(null === $value) {
			return haxe_ds_Option::$None;
		} else {
			return haxe_ds_Option::Some($value);
		}
	}
	static function get($option) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return _hx_deref($option)->params[0];
		}break;
		case 1:{
			return null;
		}break;
		}
	}
	static function getOrElse($option, $alt) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return _hx_deref($option)->params[0];
		}break;
		case 1:{
			return $alt;
		}break;
		}
	}
	static function orElse($option, $alt) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return $option;
		}break;
		case 1:{
			return $alt;
		}break;
		}
	}
	static function all($option, $f) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return call_user_func_array($f, array(_hx_deref($option)->params[0]));
		}break;
		case 1:{
			return true;
		}break;
		}
	}
	static function any($option, $f) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return call_user_func_array($f, array(_hx_deref($option)->params[0]));
		}break;
		case 1:{
			return false;
		}break;
		}
	}
	static function traverseValidation($option, $f) {
		switch(Type::enumIndex($option)) {
		case 0:{
			$this1 = call_user_func_array($f, array(_hx_deref($option)->params[0]));
			$tmp = thx_Either::Right(array(new _hx_lambda(array(), "thx_Options_3"), 'execute'));
			return thx__Validation_Validation_Impl_::ap($this1, $tmp, array(new _hx_lambda(array(), "thx_Options_4"), 'execute'));
		}break;
		case 1:{
			return thx_Either::Right(haxe_ds_Option::$None);
		}break;
		}
	}
	static function toSuccess($option, $error) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return thx_Either::Right(_hx_deref($option)->params[0]);
		}break;
		case 1:{
			return thx_Either::Left($error);
		}break;
		}
	}
	static function toSuccessNel($option, $error) {
		switch(Type::enumIndex($option)) {
		case 0:{
			return thx_Either::Right(_hx_deref($option)->params[0]);
		}break;
		case 1:{
			$tmp = thx__Nel_Nel_Impl_::pure($error);
			return thx_Either::Left($tmp);
		}break;
		}
	}
	static function toFailure($error, $value) {
		switch(Type::enumIndex($error)) {
		case 0:{
			return thx_Either::Left(_hx_deref($error)->params[0]);
		}break;
		case 1:{
			return thx_Either::Right($value);
		}break;
		}
	}
	static function toFailureNel($error, $value) {
		switch(Type::enumIndex($error)) {
		case 0:{
			$tmp = thx__Nel_Nel_Impl_::pure(_hx_deref($error)->params[0]);
			return thx_Either::Left($tmp);
		}break;
		case 1:{
			return thx_Either::Right($value);
		}break;
		}
	}
	static function ap2($f, $v1, $v2) {
		$tmp = thx_Functions2::curry($f);
		$tmp1 = thx_Options::map($v1, $tmp);
		return thx_Options::ap($v2, $tmp1);
	}
	static function ap3($f, $v1, $v2, $v3) {
		$tmp = thx_Functions3::curry($f);
		$tmp1 = thx_Options::ap2($tmp, $v1, $v2);
		return thx_Options::ap($v3, $tmp1);
	}
	static function ap4($f, $v1, $v2, $v3, $v4) {
		$tmp = thx_Functions4::curry($f);
		$tmp1 = thx_Options::ap3($tmp, $v1, $v2, $v3);
		return thx_Options::ap($v4, $tmp1);
	}
	static function ap5($f, $v1, $v2, $v3, $v4, $v5) {
		$tmp = thx_Functions5::curry($f);
		$tmp1 = thx_Options::ap4($tmp, $v1, $v2, $v3, $v4);
		return thx_Options::ap($v5, $tmp1);
	}
	static function ap6($f, $v1, $v2, $v3, $v4, $v5, $v6) {
		$tmp = thx_Functions6::curry($f);
		$tmp1 = thx_Options::ap5($tmp, $v1, $v2, $v3, $v4, $v5);
		return thx_Options::ap($v6, $tmp1);
	}
	static function ap7($f, $v1, $v2, $v3, $v4, $v5, $v6, $v7) {
		$tmp = thx_Functions7::curry($f);
		$tmp1 = thx_Options::ap6($tmp, $v1, $v2, $v3, $v4, $v5, $v6);
		return thx_Options::ap($v7, $tmp1);
	}
	static function ap8($f, $v1, $v2, $v3, $v4, $v5, $v6, $v7, $v8) {
		$tmp = thx_Functions8::curry($f);
		$tmp1 = thx_Options::ap7($tmp, $v1, $v2, $v3, $v4, $v5, $v6, $v7);
		return thx_Options::ap($v8, $tmp1);
	}
	function __toString() { return 'thx.Options'; }
}
function thx_Options_0($a2, $b2) {
	{
		return (is_object($_t = $a2) && ($_t instanceof Enum) ? $_t == $b2 : _hx_equal($_t, $b2));
	}
}
function thx_Options_1(&$v, $f) {
	{
		return call_user_func_array($f, array($v));
	}
}
function thx_Options_2(&$_e, $a0, $a1) {
	{
		return thx__Monoid_Monoid_Impl_::append($_e, $a0, $a1);
	}
}
function thx_Options_3($v) {
	{
		return haxe_ds_Option::Some($v);
	}
}
function thx_Options_4($e1, $e2) {
	{
		throw new HException("Unreachable");
	}
}
