<?php

// Generated by Haxe 3.3.0
class thx_Dynamics {
	public function __construct(){}
	static function equals($a, $b) {
		$tmp = !thx_Types::sameType($a, $b);
		if($tmp) {
			return false;
		}
		if((is_object($_t = $a) && ($_t instanceof Enum) ? $_t == $b : _hx_equal($_t, $b))) {
			return true;
		}
		$_g = Type::typeof($a);
		switch(Type::enumIndex($_g)) {
		case 0:case 1:case 2:case 3:{
			return false;
		}break;
		case 4:{
			$fa = Reflect::fields($a);
			$fb = Reflect::fields($b);
			{
				$_g1 = 0;
				while($_g1 < $fa->length) {
					$field = $fa[$_g1];
					++$_g1;
					$fb->remove($field);
					$tmp1 = !Reflect::hasField($b, $field);
					if($tmp1) {
						return false;
					}
					$va = Reflect::field($a, $field);
					$tmp2 = Reflect::isFunction($va);
					if($tmp2) {
						continue;
					}
					$vb = Reflect::field($b, $field);
					$tmp3 = !thx_Dynamics::equals($va, $vb);
					if($tmp3) {
						return false;
					}
					unset($vb,$va,$tmp3,$tmp2,$tmp1,$field);
				}
			}
			if($fb->length > 0) {
				return false;
			}
			$t = false;
			$tmp4 = null;
			$t = thx_Iterators::isIterator($a);
			if(!$t) {
				$tmp4 = thx_Iterables::isIterable($a);
			} else {
				$tmp4 = true;
			}
			if($tmp4) {
				$tmp5 = null;
				if($t) {
					$tmp5 = !thx_Iterators::isIterator($b);
				} else {
					$tmp5 = false;
				}
				if($tmp5) {
					return false;
				}
				$tmp6 = null;
				if(!$t) {
					$tmp6 = !thx_Iterables::isIterable($b);
				} else {
					$tmp6 = false;
				}
				if($tmp6) {
					return false;
				}
				$aa = null;
				if($t) {
					$aa = thx_Iterators::toArray($a);
				} else {
					$aa = thx_Iterables::toArray($a);
				}
				$ab = null;
				if($t) {
					$ab = thx_Iterators::toArray($b);
				} else {
					$ab = thx_Iterables::toArray($b);
				}
				if($aa->length !== $ab->length) {
					return false;
				}
				{
					$_g11 = 0;
					$_g2 = $aa->length;
					while($_g11 < $_g2) {
						$i = $_g11++;
						$tmp7 = !thx_Dynamics::equals($aa[$i], $ab[$i]);
						if($tmp7) {
							return false;
						}
						unset($tmp7,$i);
					}
				}
				return true;
			}
			return true;
		}break;
		case 5:{
			return Reflect::compareMethods($a, $b);
		}break;
		case 6:{
			$c = _hx_deref($_g)->params[0];
			$ca = Type::getClassName($c);
			$tmp8 = Type::getClass($b);
			$cb = Type::getClassName($tmp8);
			if($ca !== $cb) {
				return false;
			}
			$tmp9 = Std::is($a, _hx_qtype("String"));
			if($tmp9) {
				return false;
			}
			$tmp10 = Std::is($a, _hx_qtype("Array"));
			if($tmp10) {
				$aa1 = $a;
				$ab1 = $b;
				if($aa1->length !== $ab1->length) {
					return false;
				}
				{
					$_g12 = 0;
					$_g3 = $aa1->length;
					while($_g12 < $_g3) {
						$i1 = $_g12++;
						$tmp11 = !thx_Dynamics::equals($aa1[$i1], $ab1[$i1]);
						if($tmp11) {
							return false;
						}
						unset($tmp11,$i1);
					}
				}
				return true;
			}
			$tmp12 = Std::is($a, _hx_qtype("Date"));
			if($tmp12) {
				$tmp13 = $a->getTime();
				$tmp14 = $b->getTime();
				return _hx_equal($tmp13, $tmp14);
			}
			$tmp15 = thx_Maps::isMap($a);
			if($tmp15) {
				$ha = $a;
				$hb = $b;
				$tmp16 = $ha->keys();
				$ka = thx_Iterators::toArray($tmp16);
				$tmp17 = $hb->keys();
				$kb = thx_Iterators::toArray($tmp17);
				if($ka->length !== $kb->length) {
					return false;
				}
				{
					$_g4 = 0;
					while($_g4 < $ka->length) {
						$key = $ka[$_g4];
						++$_g4;
						$tmp18 = null;
						$tmp19 = !(!$hb->exists($key));
						if($tmp19) {
							$tmp20 = $ha->get($key);
							$tmp18 = !thx_Dynamics::equals($tmp20, $hb->get($key));
							unset($tmp20);
						} else {
							$tmp18 = true;
						}
						if($tmp18) {
							return false;
						}
						unset($tmp19,$tmp18,$key);
					}
				}
				return true;
			}
			$t1 = false;
			$tmp21 = null;
			$t1 = thx_Iterators::isIterator($a);
			if(!$t1) {
				$tmp21 = thx_Iterables::isIterable($a);
			} else {
				$tmp21 = true;
			}
			if($tmp21) {
				$va1 = null;
				if($t1) {
					$va1 = thx_Iterators::toArray($a);
				} else {
					$va1 = thx_Iterables::toArray($a);
				}
				$vb1 = null;
				if($t1) {
					$vb1 = thx_Iterators::toArray($b);
				} else {
					$vb1 = thx_Iterables::toArray($b);
				}
				if($va1->length !== $vb1->length) {
					return false;
				}
				{
					$_g13 = 0;
					$_g5 = $va1->length;
					while($_g13 < $_g5) {
						$i2 = $_g13++;
						$tmp22 = !thx_Dynamics::equals($va1[$i2], $vb1[$i2]);
						if($tmp22) {
							return false;
						}
						unset($tmp22,$i2);
					}
				}
				return true;
			}
			$f = null;
			$tmp23 = null;
			$tmp24 = Reflect::hasField($a, "equals");
			if($tmp24) {
				$f = Reflect::field($a, "equals");
				$tmp23 = Reflect::isFunction($f);
			} else {
				$tmp23 = false;
			}
			if($tmp23) {
				return Reflect::callMethod($a, $f, (new _hx_array(array($b))));
			}
			$tmp25 = Type::getClass($a);
			$fields = Type::getInstanceFields($tmp25);
			{
				$_g6 = 0;
				while($_g6 < $fields->length) {
					$field1 = $fields[$_g6];
					++$_g6;
					$va2 = Reflect::field($a, $field1);
					$tmp26 = Reflect::isFunction($va2);
					if($tmp26) {
						continue;
					}
					$vb2 = Reflect::field($b, $field1);
					$tmp27 = !thx_Dynamics::equals($va2, $vb2);
					if($tmp27) {
						return false;
					}
					unset($vb2,$va2,$tmp27,$tmp26,$field1);
				}
			}
			return true;
		}break;
		case 7:{
			$e = _hx_deref($_g)->params[0];
			$ea = Type::getEnumName($e);
			$teb = Type::getEnum($b);
			$eb = Type::getEnumName($teb);
			if($ea !== $eb) {
				return false;
			}
			if(Type::enumIndex($a) !== Type::enumIndex($b)) {
				return false;
			}
			$pa = Type::enumParameters($a);
			$pb = Type::enumParameters($b);
			{
				$_g14 = 0;
				$_g7 = $pa->length;
				while($_g14 < $_g7) {
					$i3 = $_g14++;
					$tmp28 = !thx_Dynamics::equals($pa[$i3], $pb[$i3]);
					if($tmp28) {
						return false;
					}
					unset($tmp28,$i3);
				}
			}
			return true;
		}break;
		case 8:{
			throw new HException("Unable to compare two unknown types");
		}break;
		}
	}
	static function hclone($v, $cloneInstances = null) {
		if($cloneInstances === null) {
			$cloneInstances = false;
		}
		$_g = Type::typeof($v);
		switch(Type::enumIndex($_g)) {
		case 0:{
			return null;
		}break;
		case 4:{
			return thx_Objects::copyTo($v, _hx_anonymous(array()), null);
		}break;
		case 6:{
			$c = _hx_deref($_g)->params[0];
			switch(Type::getClassName($c)) {
			case "Array":{
				return $v->map(array(new _hx_lambda(array(&$cloneInstances), "thx_Dynamics_0"), 'execute'));
			}break;
			case "Date":case "String":{
				return $v;
			}break;
			default:{
				if($cloneInstances) {
					$o = Type::createEmptyInstance($c);
					{
						$_g1 = 0;
						$_g11 = Type::getInstanceFields($c);
						while($_g1 < $_g11->length) {
							$field = $_g11[$_g1];
							++$_g1;
							$tmp = Reflect::field($v, $field);
							$tmp1 = thx_Dynamics::hclone($tmp, $cloneInstances);
							Reflect::setField($o, $field, $tmp1);
							unset($tmp1,$tmp,$field);
						}
					}
					return $o;
				} else {
					return $v;
				}
			}break;
			}
		}break;
		case 1:case 2:case 3:case 5:case 7:case 8:{
			return $v;
		}break;
		}
	}
	static function compare($a, $b) {
		$tmp = null;
		if(null === $a) {
			$tmp = null === $b;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return 0;
		}
		if(null === $a) {
			return -1;
		}
		if(null === $b) {
			return 1;
		}
		$tmp1 = !thx_Types::sameType($a, $b);
		if($tmp1) {
			$tmp2 = thx_Types::valueTypeToString($a);
			$tmp3 = thx_Types::valueTypeToString($b);
			return thx_Strings::compare($tmp2, $tmp3);
		}
		$_g = Type::typeof($a);
		switch(Type::enumIndex($_g)) {
		case 1:{
			return thx_Ints::compare($a, $b);
		}break;
		case 2:{
			return thx_Floats::compare($a, $b);
		}break;
		case 3:{
			return thx_Bools::compare($a, $b);
		}break;
		case 4:{
			return thx_Objects::compare($a, $b);
		}break;
		case 6:{
			switch(Type::getClassName(_hx_deref($_g)->params[0])) {
			case "Array":{
				return thx_Arrays::compare($a, $b);
			}break;
			case "Date":{
				return thx_Dates::compare($a, $b);
			}break;
			case "String":{
				return thx_Strings::compare($a, $b);
			}break;
			default:{
				$tmp4 = Reflect::hasField($a, "compare");
				if($tmp4) {
					$tmp5 = Reflect::field($a, "compare");
					return Reflect::callMethod($a, $tmp5, (new _hx_array(array($b))));
				} else {
					$tmp6 = Std::string($a);
					$tmp7 = Std::string($b);
					return thx_Strings::compare($tmp6, $tmp7);
				}
			}break;
			}
		}break;
		case 7:{
			return thx_Enums::compare($a, $b);
		}break;
		default:{
			return 0;
		}break;
		}
	}
	static function string($v) {
		$_g = Type::typeof($v);
		switch(Type::enumIndex($_g)) {
		case 0:{
			return "null";
		}break;
		case 1:case 2:case 3:{
			$tmp = Std::string($v);
			return "" . _hx_string_or_null($tmp);
		}break;
		case 4:{
			return thx_Objects::string($v);
		}break;
		case 5:{
			return "<function>";
		}break;
		case 6:{
			switch(Type::getClassName(_hx_deref($_g)->params[0])) {
			case "Array":{
				return thx_Arrays::string($v);
			}break;
			case "Date":{
				return $v->toString();
			}break;
			case "String":{
				return $v;
			}break;
			default:{
				$tmp1 = thx_Maps::isMap($v);
				if($tmp1) {
					return thx_Maps::string($v);
				} else {
					return Std::string($v);
				}
			}break;
			}
		}break;
		case 7:{
			return thx_Enums::string($v);
		}break;
		case 8:{
			return "<unknown>";
		}break;
		}
	}
	function __toString() { return 'thx.Dynamics'; }
}
function thx_Dynamics_0(&$cloneInstances, $v1) {
	{
		return thx_Dynamics::hclone($v1, $cloneInstances);
	}
}
