<?php

// Generated by Haxe 3.3.0
class utest_Assert {
	public function __construct(){}
	static $results;
	static function isTrue($cond, $msg = null, $pos = null) {
		if(utest_Assert::$results === null) {
			throw new HException("Assert.results is not currently bound to any assert context");
		}
		$tmp = null === $msg;
		if($tmp) {
			$msg = "expected true";
		}
		if($cond) {
			$tmp1 = utest_Assertation::Success($pos);
			utest_Assert::$results->add($tmp1);
		} else {
			$tmp2 = utest_Assertation::Failure($msg, $pos);
			utest_Assert::$results->add($tmp2);
		}
	}
	static function isFalse($value, $msg = null, $pos = null) {
		$tmp = null === $msg;
		if($tmp) {
			$msg = "expected false";
		}
		utest_Assert::isTrue($value === false, $msg, $pos);
	}
	static function isNull($value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = utest_Assert::q($value);
			$msg = "expected null but it is " . _hx_string_or_null($tmp);
		}
		utest_Assert::isTrue($value === null, $msg, $pos);
	}
	static function notNull($value, $msg = null, $pos = null) {
		$tmp = null === $msg;
		if($tmp) {
			$msg = "expected not null";
		}
		utest_Assert::isTrue($value !== null, $msg, $pos);
	}
	static function is($value, $type, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = utest_Assert::typeToString($type);
			$tmp1 = "expected type " . _hx_string_or_null($tmp) . " but it is ";
			$tmp2 = utest_Assert::typeToString($value);
			$msg = _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2);
		}
		$tmp3 = Std::is($value, $type);
		utest_Assert::isTrue($tmp3, $msg, $pos);
	}
	static function notEquals($expected, $value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = utest_Assert::q($expected);
			$tmp1 = "expected " . _hx_string_or_null($tmp) . " and test value ";
			$tmp2 = utest_Assert::q($value);
			$msg = _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2) . " should be different";
		}
		utest_Assert::isFalse(_hx_equal($expected, $value), $msg, $pos);
	}
	static function equals($expected, $value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = utest_Assert::q($expected);
			$tmp1 = "expected " . _hx_string_or_null($tmp) . " but it is ";
			$tmp2 = utest_Assert::q($value);
			$msg = _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2);
		}
		utest_Assert::isTrue(_hx_equal($expected, $value), $msg, $pos);
	}
	static function match($pattern, $value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = utest_Assert::q($value);
			$msg = "the value " . _hx_string_or_null($tmp) . " does not match the provided pattern";
		}
		$tmp1 = $pattern->match($value);
		utest_Assert::isTrue($tmp1, $msg, $pos);
	}
	static function floatEquals($expected, $value, $approx = null, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = utest_Assert::q($expected);
			$tmp1 = "expected " . _hx_string_or_null($tmp) . " but it is ";
			$tmp2 = utest_Assert::q($value);
			$msg = _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2);
		}
		$tmp3 = utest_Assert::_floatEquals($expected, $value, $approx);
		utest_Assert::isTrue($tmp3, $msg, $pos);
		return;
	}
	static function _floatEquals($expected, $value, $approx = null) {
		$tmp = Math::isNaN($expected);
		if($tmp) {
			return Math::isNaN($value);
		} else {
			$tmp1 = Math::isNaN($value);
			if($tmp1) {
				return false;
			} else {
				$tmp2 = null;
				$tmp3 = !Math::isFinite($expected);
				if($tmp3) {
					$tmp2 = !Math::isFinite($value);
				} else {
					$tmp2 = false;
				}
				if($tmp2) {
					return (is_object($_t = ($expected > 0)) && ($_t instanceof Enum) ? $_t == $value > 0 : _hx_equal($_t, $value > 0));
				}
			}
		}
		$tmp4 = null === $approx;
		if($tmp4) {
			$approx = 1e-5;
		}
		$tmp5 = Math::abs($value - $expected);
		return $tmp5 <= $approx;
	}
	static function getTypeName($v) {
		$_g = Type::typeof($v);
		switch(Type::enumIndex($_g)) {
		case 0:{
			return "`null`";
		}break;
		case 1:{
			return "Int";
		}break;
		case 2:{
			return "Float";
		}break;
		case 3:{
			return "Bool";
		}break;
		case 4:{
			return "Object";
		}break;
		case 5:{
			return "function";
		}break;
		case 6:{
			return Type::getClassName(_hx_deref($_g)->params[0]);
		}break;
		case 7:{
			return Type::getEnumName(_hx_deref($_g)->params[0]);
		}break;
		case 8:{
			return "`Unknown`";
		}break;
		}
	}
	static function isIterable($v, $isAnonym) {
		$fields = null;
		if($isAnonym) {
			$fields = Reflect::fields($v);
		} else {
			$tmp = Type::getClass($v);
			$fields = Type::getInstanceFields($tmp);
		}
		$tmp1 = !Lambda::has($fields, "iterator");
		if($tmp1) {
			return false;
		}
		$tmp2 = Reflect::field($v, "iterator");
		return Reflect::isFunction($tmp2);
	}
	static function isIterator($v, $isAnonym) {
		$fields = null;
		if($isAnonym) {
			$fields = Reflect::fields($v);
		} else {
			$tmp = Type::getClass($v);
			$fields = Type::getInstanceFields($tmp);
		}
		$tmp1 = null;
		$tmp2 = !(!Lambda::has($fields, "next"));
		if($tmp2) {
			$tmp1 = !Lambda::has($fields, "hasNext");
		} else {
			$tmp1 = true;
		}
		if($tmp1) {
			return false;
		}
		$tmp3 = Reflect::field($v, "next");
		$tmp4 = Reflect::isFunction($tmp3);
		if($tmp4) {
			$tmp5 = Reflect::field($v, "hasNext");
			return Reflect::isFunction($tmp5);
		} else {
			return false;
		}
	}
	static function sameAs($expected, $value, $status, $approx) {
		$texpected = utest_Assert::getTypeName($expected);
		$tvalue = utest_Assert::getTypeName($value);
		$tmp = null;
		if($texpected !== $tvalue) {
			$tmp1 = null;
			$tmp2 = null;
			if($texpected === "Int") {
				$tmp2 = $tvalue === "Float";
			} else {
				$tmp2 = false;
			}
			if(!$tmp2) {
				if($texpected === "Float") {
					$tmp1 = $tvalue === "Int";
				} else {
					$tmp1 = false;
				}
			} else {
				$tmp1 = true;
			}
			$tmp = !$tmp1;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$tmp3 = "expected type " . _hx_string_or_null($texpected) . " but it is " . _hx_string_or_null($tvalue);
			$tmp4 = null;
			if($status->path === "") {
				$tmp4 = "";
			} else {
				$tmp4 = " for field " . _hx_string_or_null($status->path);
			}
			$status->error = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
			return false;
		}
		$_g = Type::typeof($expected);
		switch(Type::enumIndex($_g)) {
		case 0:case 3:{
			if(!_hx_equal($expected, $value)) {
				$tmp5 = utest_Assert::q($expected);
				$tmp6 = "expected " . _hx_string_or_null($tmp5) . " but it is ";
				$tmp7 = utest_Assert::q($value);
				$tmp8 = _hx_string_or_null($tmp6) . _hx_string_or_null($tmp7);
				$tmp9 = null;
				if($status->path === "") {
					$tmp9 = "";
				} else {
					$tmp9 = " for field " . _hx_string_or_null($status->path);
				}
				$status->error = _hx_string_or_null($tmp8) . _hx_string_or_null($tmp9);
				return false;
			}
			return true;
		}break;
		case 1:case 2:{
			$tmp10 = !utest_Assert::_floatEquals($expected, $value, $approx);
			if($tmp10) {
				$tmp11 = utest_Assert::q($expected);
				$tmp12 = "expected " . _hx_string_or_null($tmp11) . " but it is ";
				$tmp13 = utest_Assert::q($value);
				$tmp14 = _hx_string_or_null($tmp12) . _hx_string_or_null($tmp13);
				$tmp15 = null;
				if($status->path === "") {
					$tmp15 = "";
				} else {
					$tmp15 = " for field " . _hx_string_or_null($status->path);
				}
				$status->error = _hx_string_or_null($tmp14) . _hx_string_or_null($tmp15);
				return false;
			}
			return true;
		}break;
		case 4:{
			$tmp16 = null;
			if(!$status->recursive) {
				$tmp16 = $status->path === "";
			} else {
				$tmp16 = true;
			}
			if($tmp16) {
				$tfields = Reflect::fields($value);
				$fields = Reflect::fields($expected);
				$path = $status->path;
				{
					$_g1 = 0;
					while($_g1 < $fields->length) {
						$field = $fields[$_g1];
						++$_g1;
						$tfields->remove($field);
						$tmp17 = null;
						if($path === "") {
							$tmp17 = $field;
						} else {
							$tmp17 = _hx_string_or_null($path) . "." . _hx_string_or_null($field);
						}
						$status->path = $tmp17;
						$tmp18 = !Reflect::hasField($value, $field);
						if($tmp18) {
							$tmp19 = "expected field " . _hx_string_or_null($status->path) . " does not exist in ";
							$tmp20 = utest_Assert::q($value);
							$status->error = _hx_string_or_null($tmp19) . _hx_string_or_null($tmp20);
							return false;
							unset($tmp20,$tmp19);
						}
						$e = Reflect::field($expected, $field);
						$tmp21 = Reflect::isFunction($e);
						if($tmp21) {
							continue;
						}
						$v = Reflect::field($value, $field);
						$tmp22 = !utest_Assert::sameAs($e, $v, $status, $approx);
						if($tmp22) {
							return false;
						}
						unset($v,$tmp22,$tmp21,$tmp18,$tmp17,$field,$e);
					}
				}
				$tmp23 = $tfields->length > 0;
				if($tmp23) {
					$tmp24 = $tfields->join(", ");
					$status->error = "the tested object has extra field(s) (" . _hx_string_or_null($tmp24) . ") not included in the expected ones";
					return false;
				}
			}
			$tmp25 = utest_Assert::isIterator($expected, true);
			if($tmp25) {
				$tmp26 = !utest_Assert::isIterator($value, true);
				if($tmp26) {
					$tmp27 = null;
					if($status->path === "") {
						$tmp27 = "";
					} else {
						$tmp27 = " for field " . _hx_string_or_null($status->path);
					}
					$status->error = "expected Iterable but it is not " . _hx_string_or_null($tmp27);
					return false;
				}
				$tmp28 = null;
				if(!$status->recursive) {
					$tmp28 = $status->path === "";
				} else {
					$tmp28 = true;
				}
				if($tmp28) {
					$evalues = Lambda::harray(_hx_anonymous(array("iterator" => array(new _hx_lambda(array(&$expected), "utest_Assert_0"), 'execute'))));
					$vvalues = Lambda::harray(_hx_anonymous(array("iterator" => array(new _hx_lambda(array(&$value), "utest_Assert_1"), 'execute'))));
					$tmp29 = $evalues->length !== $vvalues->length;
					if($tmp29) {
						$tmp30 = "expected " . _hx_string_rec($evalues->length, "") . " values in Iterator but they are " . _hx_string_rec($vvalues->length, "");
						$tmp31 = null;
						if($status->path === "") {
							$tmp31 = "";
						} else {
							$tmp31 = " for field " . _hx_string_or_null($status->path);
						}
						$status->error = _hx_string_or_null($tmp30) . _hx_string_or_null($tmp31);
						return false;
					}
					$path1 = $status->path;
					{
						$_g11 = 0;
						$_g2 = $evalues->length;
						while($_g11 < $_g2) {
							$i = $_g11++;
							$tmp32 = null;
							if($path1 === "") {
								$tmp32 = "iterator[" . _hx_string_rec($i, "") . "]";
							} else {
								$tmp32 = _hx_string_or_null($path1) . "[" . _hx_string_rec($i, "") . "]";
							}
							$status->path = $tmp32;
							$tmp33 = !utest_Assert::sameAs($evalues[$i], $vvalues[$i], $status, $approx);
							if($tmp33) {
								$tmp34 = utest_Assert::q($expected);
								$tmp35 = "expected " . _hx_string_or_null($tmp34) . " but it is ";
								$tmp36 = utest_Assert::q($value);
								$tmp37 = _hx_string_or_null($tmp35) . _hx_string_or_null($tmp36);
								$tmp38 = null;
								if($status->path === "") {
									$tmp38 = "";
								} else {
									$tmp38 = " for field " . _hx_string_or_null($status->path);
								}
								$status->error = _hx_string_or_null($tmp37) . _hx_string_or_null($tmp38);
								return false;
								unset($tmp38,$tmp37,$tmp36,$tmp35,$tmp34);
							}
							unset($tmp33,$tmp32,$i);
						}
					}
				}
				return true;
			}
			$tmp39 = utest_Assert::isIterable($expected, true);
			if($tmp39) {
				$tmp40 = !utest_Assert::isIterable($value, true);
				if($tmp40) {
					$tmp41 = null;
					if($status->path === "") {
						$tmp41 = "";
					} else {
						$tmp41 = " for field " . _hx_string_or_null($status->path);
					}
					$status->error = "expected Iterator but it is not " . _hx_string_or_null($tmp41);
					return false;
				}
				$tmp42 = null;
				if(!$status->recursive) {
					$tmp42 = $status->path === "";
				} else {
					$tmp42 = true;
				}
				if($tmp42) {
					$evalues1 = Lambda::harray($expected);
					$vvalues1 = Lambda::harray($value);
					$tmp43 = $evalues1->length !== $vvalues1->length;
					if($tmp43) {
						$tmp44 = "expected " . _hx_string_rec($evalues1->length, "") . " values in Iterable but they are " . _hx_string_rec($vvalues1->length, "");
						$tmp45 = null;
						if($status->path === "") {
							$tmp45 = "";
						} else {
							$tmp45 = " for field " . _hx_string_or_null($status->path);
						}
						$status->error = _hx_string_or_null($tmp44) . _hx_string_or_null($tmp45);
						return false;
					}
					$path2 = $status->path;
					{
						$_g12 = 0;
						$_g3 = $evalues1->length;
						while($_g12 < $_g3) {
							$i1 = $_g12++;
							$tmp46 = null;
							if($path2 === "") {
								$tmp46 = "iterable[" . _hx_string_rec($i1, "") . "]";
							} else {
								$tmp46 = _hx_string_or_null($path2) . "[" . _hx_string_rec($i1, "") . "]";
							}
							$status->path = $tmp46;
							$tmp47 = !utest_Assert::sameAs($evalues1[$i1], $vvalues1[$i1], $status, $approx);
							if($tmp47) {
								return false;
							}
							unset($tmp47,$tmp46,$i1);
						}
					}
				}
				return true;
			}
			return true;
		}break;
		case 5:{
			$tmp48 = !Reflect::compareMethods($expected, $value);
			if($tmp48) {
				$tmp49 = null;
				if($status->path === "") {
					$tmp49 = "";
				} else {
					$tmp49 = " for field " . _hx_string_or_null($status->path);
				}
				$status->error = "expected same function reference" . _hx_string_or_null($tmp49);
				return false;
			}
			return true;
		}break;
		case 6:{
			$cexpected = Type::getClassName(_hx_deref($_g)->params[0]);
			$tmp50 = Type::getClass($value);
			$cvalue = Type::getClassName($tmp50);
			if($cexpected !== $cvalue) {
				$tmp51 = utest_Assert::q($cexpected);
				$tmp52 = "expected instance of " . _hx_string_or_null($tmp51) . " but it is ";
				$tmp53 = utest_Assert::q($cvalue);
				$tmp54 = _hx_string_or_null($tmp52) . _hx_string_or_null($tmp53);
				$tmp55 = null;
				if($status->path === "") {
					$tmp55 = "";
				} else {
					$tmp55 = " for field " . _hx_string_or_null($status->path);
				}
				$status->error = _hx_string_or_null($tmp54) . _hx_string_or_null($tmp55);
				return false;
			}
			$tmp56 = null;
			$tmp57 = Std::is($expected, _hx_qtype("String"));
			if($tmp57) {
				$tmp56 = !_hx_equal($expected, $value);
			} else {
				$tmp56 = false;
			}
			if($tmp56) {
				$tmp58 = Std::string($expected);
				$tmp59 = "expected '" . _hx_string_or_null($tmp58) . "' but it is '";
				$tmp60 = Std::string($value);
				$status->error = _hx_string_or_null($tmp59) . _hx_string_or_null($tmp60) . "'";
				return false;
			}
			$tmp61 = Std::is($expected, _hx_qtype("Array"));
			if($tmp61) {
				$tmp62 = null;
				if(!$status->recursive) {
					$tmp62 = $status->path === "";
				} else {
					$tmp62 = true;
				}
				if($tmp62) {
					$tmp63 = !_hx_equal(_hx_len($expected), _hx_len($value));
					if($tmp63) {
						$tmp64 = Std::string(_hx_len($expected));
						$tmp65 = "expected " . _hx_string_or_null($tmp64) . " elements but they are ";
						$tmp66 = Std::string(_hx_len($value));
						$tmp67 = _hx_string_or_null($tmp65) . _hx_string_or_null($tmp66);
						$tmp68 = null;
						if($status->path === "") {
							$tmp68 = "";
						} else {
							$tmp68 = " for field " . _hx_string_or_null($status->path);
						}
						$status->error = _hx_string_or_null($tmp67) . _hx_string_or_null($tmp68);
						return false;
					}
					$path3 = $status->path;
					{
						$_g13 = 0;
						$_g4 = _hx_len($expected);
						while($_g13 < $_g4) {
							$i2 = $_g13++;
							$tmp69 = null;
							if($path3 === "") {
								$tmp69 = "array[" . _hx_string_rec($i2, "") . "]";
							} else {
								$tmp69 = _hx_string_or_null($path3) . "[" . _hx_string_rec($i2, "") . "]";
							}
							$status->path = $tmp69;
							$tmp70 = !utest_Assert::sameAs($expected[$i2], $value[$i2], $status, $approx);
							if($tmp70) {
								$tmp71 = utest_Assert::q($expected[$i2]);
								$tmp72 = "expected " . _hx_string_or_null($tmp71) . " but it is ";
								$tmp73 = utest_Assert::q($value[$i2]);
								$tmp74 = _hx_string_or_null($tmp72) . _hx_string_or_null($tmp73);
								$tmp75 = null;
								if($status->path === "") {
									$tmp75 = "";
								} else {
									$tmp75 = " for field " . _hx_string_or_null($status->path);
								}
								$status->error = _hx_string_or_null($tmp74) . _hx_string_or_null($tmp75);
								return false;
								unset($tmp75,$tmp74,$tmp73,$tmp72,$tmp71);
							}
							unset($tmp70,$tmp69,$i2);
						}
					}
				}
				return true;
			}
			$tmp76 = Std::is($expected, _hx_qtype("Date"));
			if($tmp76) {
				$tmp77 = $expected->getTime();
				$tmp78 = $value->getTime();
				if(!_hx_equal($tmp77, $tmp78)) {
					$tmp79 = utest_Assert::q($expected);
					$tmp80 = "expected " . _hx_string_or_null($tmp79) . " but it is ";
					$tmp81 = utest_Assert::q($value);
					$tmp82 = _hx_string_or_null($tmp80) . _hx_string_or_null($tmp81);
					$tmp83 = null;
					if($status->path === "") {
						$tmp83 = "";
					} else {
						$tmp83 = " for field " . _hx_string_or_null($status->path);
					}
					$status->error = _hx_string_or_null($tmp82) . _hx_string_or_null($tmp83);
					return false;
				}
				return true;
			}
			$tmp84 = Std::is($expected, _hx_qtype("haxe.io.Bytes"));
			if($tmp84) {
				$tmp85 = null;
				if(!$status->recursive) {
					$tmp85 = $status->path === "";
				} else {
					$tmp85 = true;
				}
				if($tmp85) {
					$ebytes = $expected;
					$vbytes = $value;
					if($ebytes->length !== $vbytes->length) {
						return false;
					}
					{
						$_g14 = 0;
						$_g5 = $ebytes->length;
						while($_g14 < $_g5) {
							$i3 = $_g14++;
							$tmp86 = $ebytes->get($i3);
							$tmp87 = $vbytes->get($i3);
							if($tmp86 !== $tmp87) {
								$tmp88 = $ebytes->get($i3);
								$tmp89 = "expected byte " . _hx_string_rec($tmp88, "") . " but it is ";
								$tmp90 = $vbytes->get($i3);
								$tmp91 = _hx_string_or_null($tmp89) . _hx_string_rec($tmp90, "");
								$tmp92 = null;
								if($status->path === "") {
									$tmp92 = "";
								} else {
									$tmp92 = " for field " . _hx_string_or_null($status->path);
								}
								$status->error = _hx_string_or_null($tmp91) . _hx_string_or_null($tmp92);
								return false;
								unset($tmp92,$tmp91,$tmp90,$tmp89,$tmp88);
							}
							unset($tmp87,$tmp86,$i3);
						}
					}
				}
				return true;
			}
			$tmp93 = Std::is($expected, _hx_qtype("haxe.IMap"));
			if($tmp93) {
				$tmp94 = null;
				if(!$status->recursive) {
					$tmp94 = $status->path === "";
				} else {
					$tmp94 = true;
				}
				if($tmp94) {
					$map = $expected;
					$vmap = $value;
					$_g6 = (new _hx_array(array()));
					{
						$tmp95 = $map->keys();
						while(true) {
							$tmp96 = !$tmp95->hasNext();
							if($tmp96) {
								break;
							}
							$k = $tmp95->next();
							$_g6->push($k);
							unset($tmp96,$k);
						}
					}
					$_g15 = (new _hx_array(array()));
					{
						$tmp97 = $vmap->keys();
						while(true) {
							$tmp98 = !$tmp97->hasNext();
							if($tmp98) {
								break;
							}
							$k1 = $tmp97->next();
							$_g15->push($k1);
							unset($tmp98,$k1);
						}
					}
					$tmp99 = $_g6->length !== $_g15->length;
					if($tmp99) {
						$tmp100 = "expected " . _hx_string_rec($_g6->length, "") . " keys but they are " . _hx_string_rec($_g15->length, "");
						$tmp101 = null;
						if($status->path === "") {
							$tmp101 = "";
						} else {
							$tmp101 = " for field " . _hx_string_or_null($status->path);
						}
						$status->error = _hx_string_or_null($tmp100) . _hx_string_or_null($tmp101);
						return false;
					}
					$path4 = $status->path;
					{
						$_g21 = 0;
						while($_g21 < $_g6->length) {
							$key = $_g6[$_g21];
							++$_g21;
							$tmp102 = null;
							if($path4 === "") {
								$tmp103 = Std::string($key);
								$tmp102 = "hash[" . _hx_string_or_null($tmp103) . "]";
								unset($tmp103);
							} else {
								$tmp104 = _hx_string_or_null($path4) . "[";
								$tmp105 = Std::string($key);
								$tmp102 = _hx_string_or_null($tmp104) . _hx_string_or_null($tmp105) . "]";
								unset($tmp105,$tmp104);
							}
							$status->path = $tmp102;
							$tmp106 = $map->get($key);
							$tmp107 = $vmap->get($key);
							$tmp108 = !utest_Assert::sameAs($tmp106, $tmp107, $status, $approx);
							if($tmp108) {
								$tmp109 = utest_Assert::q($expected);
								$tmp110 = "expected " . _hx_string_or_null($tmp109) . " but it is ";
								$tmp111 = utest_Assert::q($value);
								$tmp112 = _hx_string_or_null($tmp110) . _hx_string_or_null($tmp111);
								$tmp113 = null;
								if($status->path === "") {
									$tmp113 = "";
								} else {
									$tmp113 = " for field " . _hx_string_or_null($status->path);
								}
								$status->error = _hx_string_or_null($tmp112) . _hx_string_or_null($tmp113);
								return false;
								unset($tmp113,$tmp112,$tmp111,$tmp110,$tmp109);
							}
							unset($tmp108,$tmp107,$tmp106,$tmp102,$key);
						}
					}
				}
				return true;
			}
			$tmp114 = utest_Assert::isIterator($expected, false);
			if($tmp114) {
				$tmp115 = null;
				if(!$status->recursive) {
					$tmp115 = $status->path === "";
				} else {
					$tmp115 = true;
				}
				if($tmp115) {
					$evalues2 = Lambda::harray(_hx_anonymous(array("iterator" => array(new _hx_lambda(array(&$expected), "utest_Assert_2"), 'execute'))));
					$vvalues2 = Lambda::harray(_hx_anonymous(array("iterator" => array(new _hx_lambda(array(&$value), "utest_Assert_3"), 'execute'))));
					$tmp116 = $evalues2->length !== $vvalues2->length;
					if($tmp116) {
						$tmp117 = "expected " . _hx_string_rec($evalues2->length, "") . " values in Iterator but they are " . _hx_string_rec($vvalues2->length, "");
						$tmp118 = null;
						if($status->path === "") {
							$tmp118 = "";
						} else {
							$tmp118 = " for field " . _hx_string_or_null($status->path);
						}
						$status->error = _hx_string_or_null($tmp117) . _hx_string_or_null($tmp118);
						return false;
					}
					$path5 = $status->path;
					{
						$_g16 = 0;
						$_g7 = $evalues2->length;
						while($_g16 < $_g7) {
							$i4 = $_g16++;
							$tmp119 = null;
							if($path5 === "") {
								$tmp119 = "iterator[" . _hx_string_rec($i4, "") . "]";
							} else {
								$tmp119 = _hx_string_or_null($path5) . "[" . _hx_string_rec($i4, "") . "]";
							}
							$status->path = $tmp119;
							$tmp120 = !utest_Assert::sameAs($evalues2[$i4], $vvalues2[$i4], $status, $approx);
							if($tmp120) {
								$tmp121 = utest_Assert::q($expected);
								$tmp122 = "expected " . _hx_string_or_null($tmp121) . " but it is ";
								$tmp123 = utest_Assert::q($value);
								$tmp124 = _hx_string_or_null($tmp122) . _hx_string_or_null($tmp123);
								$tmp125 = null;
								if($status->path === "") {
									$tmp125 = "";
								} else {
									$tmp125 = " for field " . _hx_string_or_null($status->path);
								}
								$status->error = _hx_string_or_null($tmp124) . _hx_string_or_null($tmp125);
								return false;
								unset($tmp125,$tmp124,$tmp123,$tmp122,$tmp121);
							}
							unset($tmp120,$tmp119,$i4);
						}
					}
				}
				return true;
			}
			$tmp126 = utest_Assert::isIterable($expected, false);
			if($tmp126) {
				$tmp127 = null;
				if(!$status->recursive) {
					$tmp127 = $status->path === "";
				} else {
					$tmp127 = true;
				}
				if($tmp127) {
					$evalues3 = Lambda::harray($expected);
					$vvalues3 = Lambda::harray($value);
					$tmp128 = $evalues3->length !== $vvalues3->length;
					if($tmp128) {
						$tmp129 = "expected " . _hx_string_rec($evalues3->length, "") . " values in Iterable but they are " . _hx_string_rec($vvalues3->length, "");
						$tmp130 = null;
						if($status->path === "") {
							$tmp130 = "";
						} else {
							$tmp130 = " for field " . _hx_string_or_null($status->path);
						}
						$status->error = _hx_string_or_null($tmp129) . _hx_string_or_null($tmp130);
						return false;
					}
					$path6 = $status->path;
					{
						$_g17 = 0;
						$_g8 = $evalues3->length;
						while($_g17 < $_g8) {
							$i5 = $_g17++;
							$tmp131 = null;
							if($path6 === "") {
								$tmp131 = "iterable[" . _hx_string_rec($i5, "") . "]";
							} else {
								$tmp131 = _hx_string_or_null($path6) . "[" . _hx_string_rec($i5, "") . "]";
							}
							$status->path = $tmp131;
							$tmp132 = !utest_Assert::sameAs($evalues3[$i5], $vvalues3[$i5], $status, $approx);
							if($tmp132) {
								return false;
							}
							unset($tmp132,$tmp131,$i5);
						}
					}
				}
				return true;
			}
			$tmp133 = null;
			if(!$status->recursive) {
				$tmp133 = $status->path === "";
			} else {
				$tmp133 = true;
			}
			if($tmp133) {
				$tmp134 = Type::getClass($expected);
				$fields1 = Type::getInstanceFields($tmp134);
				$path7 = $status->path;
				{
					$_g9 = 0;
					while($_g9 < $fields1->length) {
						$field1 = $fields1[$_g9];
						++$_g9;
						$tmp135 = null;
						if($path7 === "") {
							$tmp135 = $field1;
						} else {
							$tmp135 = _hx_string_or_null($path7) . "." . _hx_string_or_null($field1);
						}
						$status->path = $tmp135;
						$e1 = Reflect::field($expected, $field1);
						$tmp136 = Reflect::isFunction($e1);
						if($tmp136) {
							continue;
						}
						$v1 = Reflect::field($value, $field1);
						$tmp137 = !utest_Assert::sameAs($e1, $v1, $status, $approx);
						if($tmp137) {
							return false;
						}
						unset($v1,$tmp137,$tmp136,$tmp135,$field1,$e1);
					}
				}
			}
			return true;
		}break;
		case 7:{
			$eexpected = Type::getEnumName(_hx_deref($_g)->params[0]);
			$tmp138 = Type::getEnum($value);
			$evalue = Type::getEnumName($tmp138);
			if($eexpected !== $evalue) {
				$tmp139 = utest_Assert::q($eexpected);
				$tmp140 = "expected enumeration of " . _hx_string_or_null($tmp139) . " but it is ";
				$tmp141 = utest_Assert::q($evalue);
				$tmp142 = _hx_string_or_null($tmp140) . _hx_string_or_null($tmp141);
				$tmp143 = null;
				if($status->path === "") {
					$tmp143 = "";
				} else {
					$tmp143 = " for field " . _hx_string_or_null($status->path);
				}
				$status->error = _hx_string_or_null($tmp142) . _hx_string_or_null($tmp143);
				return false;
			}
			$tmp144 = null;
			if(!$status->recursive) {
				$tmp144 = $status->path === "";
			} else {
				$tmp144 = true;
			}
			if($tmp144) {
				if(Type::enumIndex($expected) !== Type::enumIndex($value)) {
					$tmp145 = utest_Assert::q(Type::enumConstructor($expected));
					$tmp146 = "expected " . _hx_string_or_null($tmp145) . " but it is ";
					$tmp147 = utest_Assert::q(Type::enumConstructor($value));
					$tmp148 = _hx_string_or_null($tmp146) . _hx_string_or_null($tmp147);
					$tmp149 = null;
					if($status->path === "") {
						$tmp149 = "";
					} else {
						$tmp149 = " for field " . _hx_string_or_null($status->path);
					}
					$status->error = _hx_string_or_null($tmp148) . _hx_string_or_null($tmp149);
					return false;
				}
				$eparams = Type::enumParameters($expected);
				$vparams = Type::enumParameters($value);
				$path8 = $status->path;
				{
					$_g18 = 0;
					$_g10 = $eparams->length;
					while($_g18 < $_g10) {
						$i6 = $_g18++;
						$tmp150 = null;
						if($path8 === "") {
							$tmp150 = "enum[" . _hx_string_rec($i6, "") . "]";
						} else {
							$tmp150 = _hx_string_or_null($path8) . "[" . _hx_string_rec($i6, "") . "]";
						}
						$status->path = $tmp150;
						$tmp151 = !utest_Assert::sameAs($eparams[$i6], $vparams[$i6], $status, $approx);
						if($tmp151) {
							$tmp152 = utest_Assert::q($expected);
							$tmp153 = "expected " . _hx_string_or_null($tmp152) . " but it is ";
							$tmp154 = utest_Assert::q($value);
							$tmp155 = _hx_string_or_null($tmp153) . _hx_string_or_null($tmp154);
							$tmp156 = null;
							if($status->path === "") {
								$tmp156 = "";
							} else {
								$tmp156 = " for field " . _hx_string_or_null($status->path);
							}
							$status->error = _hx_string_or_null($tmp155) . _hx_string_or_null($tmp156);
							return false;
							unset($tmp156,$tmp155,$tmp154,$tmp153,$tmp152);
						}
						unset($tmp151,$tmp150,$i6);
					}
				}
			}
			return true;
		}break;
		case 8:{
			throw new HException("Unable to compare two unknown types");
		}break;
		}
	}
	static function q($v) {
		$tmp = Std::is($v, _hx_qtype("String"));
		if($tmp) {
			$tmp1 = StringTools::replace($v, "\"", "\\\"");
			return "\"" . _hx_string_or_null($tmp1) . "\"";
		} else {
			return Std::string($v);
		}
	}
	static function same($expected, $value, $recursive = null, $msg = null, $approx = null, $pos = null) {
		$tmp = null === $approx;
		if($tmp) {
			$approx = 1e-5;
		}
		$tmp1 = null;
		if(null === $recursive) {
			$tmp1 = true;
		} else {
			$tmp1 = $recursive;
		}
		$status = _hx_anonymous(array("recursive" => $tmp1, "path" => "", "error" => null));
		$tmp2 = utest_Assert::sameAs($expected, $value, $status, $approx);
		if($tmp2) {
			utest_Assert::pass($msg, $pos);
		} else {
			$tmp3 = null;
			if($msg === null) {
				$tmp3 = $status->error;
			} else {
				$tmp3 = $msg;
			}
			utest_Assert::fail($tmp3, $pos);
		}
	}
	static function raises($method, $type = null, $msgNotThrown = null, $msgWrongType = null, $pos = null) {
		try {
			call_user_func($method);
			$name = Type::getClassName($type);
			$tmp = $name === null;
			if($tmp) {
				$name = "Dynamic";
			}
			$tmp1 = null === $msgNotThrown;
			if($tmp1) {
				$msgNotThrown = "exception of type " . _hx_string_or_null($name) . " not raised";
			}
			utest_Assert::fail($msgNotThrown, $pos);
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$ex = $_ex_;
			{
				if(null === $type) {
					utest_Assert::pass(null, $pos);
				} else {
					$name1 = Type::getClassName($type);
					if(null === $msgWrongType) {
						$tmp2 = "expected throw of type " . _hx_string_or_null($name1) . " but it is ";
						$tmp3 = Std::string($ex);
						$msgWrongType = _hx_string_or_null($tmp2) . _hx_string_or_null($tmp3);
					}
					$tmp4 = Std::is($ex, $type);
					utest_Assert::isTrue($tmp4, $msgWrongType, $pos);
				}
			}
		}
	}
	static function allows($possibilities, $value, $msg = null, $pos = null) {
		$tmp = Lambda::has($possibilities, $value);
		if($tmp) {
			utest_Assert::isTrue(true, $msg, $pos);
		} else {
			$tmp1 = null;
			if($msg === null) {
				$tmp2 = utest_Assert::q($value);
				$tmp3 = "value " . _hx_string_or_null($tmp2) . " not found in the expected possibilities ";
				$tmp4 = Std::string($possibilities);
				$tmp1 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
			} else {
				$tmp1 = $msg;
			}
			utest_Assert::fail($tmp1, $pos);
		}
	}
	static function contains($match, $values, $msg = null, $pos = null) {
		$tmp = Lambda::has($values, $match);
		if($tmp) {
			utest_Assert::isTrue(true, $msg, $pos);
		} else {
			$tmp1 = null;
			if($msg === null) {
				$tmp2 = utest_Assert::q($values);
				$tmp3 = "values " . _hx_string_or_null($tmp2) . " do not contain ";
				$tmp4 = Std::string($match);
				$tmp1 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
			} else {
				$tmp1 = $msg;
			}
			utest_Assert::fail($tmp1, $pos);
		}
	}
	static function notContains($match, $values, $msg = null, $pos = null) {
		$tmp = !Lambda::has($values, $match);
		if($tmp) {
			utest_Assert::isTrue(true, $msg, $pos);
		} else {
			$tmp1 = null;
			if($msg === null) {
				$tmp2 = utest_Assert::q($values);
				$tmp3 = "values " . _hx_string_or_null($tmp2) . " do contain ";
				$tmp4 = Std::string($match);
				$tmp1 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
			} else {
				$tmp1 = $msg;
			}
			utest_Assert::fail($tmp1, $pos);
		}
	}
	static function stringContains($match, $value, $msg = null, $pos = null) {
		$tmp = null;
		if($value !== null) {
			$tmp1 = _hx_index_of($value, $match, null);
			$tmp = $tmp1 >= 0;
		} else {
			$tmp = false;
		}
		if($tmp) {
			utest_Assert::isTrue(true, $msg, $pos);
		} else {
			$tmp2 = null;
			if($msg === null) {
				$tmp3 = utest_Assert::q($value);
				$tmp4 = "value " . _hx_string_or_null($tmp3) . " does not contain ";
				$tmp5 = utest_Assert::q($match);
				$tmp2 = _hx_string_or_null($tmp4) . _hx_string_or_null($tmp5);
			} else {
				$tmp2 = $msg;
			}
			utest_Assert::fail($tmp2, $pos);
		}
	}
	static function stringSequence($sequence, $value, $msg = null, $pos = null) {
		if(null === $value) {
			$tmp = null;
			if($msg === null) {
				$tmp = "null argument value";
			} else {
				$tmp = $msg;
			}
			utest_Assert::fail($tmp, $pos);
			return;
		}
		$p = 0;
		{
			$_g = 0;
			while($_g < $sequence->length) {
				$s = $sequence[$_g];
				++$_g;
				$p2 = _hx_index_of($value, $s, $p);
				if($p2 < 0) {
					if($msg === null) {
						$msg = "expected '" . _hx_string_or_null($s) . "' after ";
						if($p > 0) {
							$cut = _hx_substr($value, 0, $p);
							$tmp1 = strlen($cut) > 30;
							if($tmp1) {
								$tmp2 = _hx_substr($cut, -27, null);
								$cut = "..." . _hx_string_or_null($tmp2);
								unset($tmp2);
							}
							$msg .= " '" . _hx_string_or_null($cut) . "'";
							unset($tmp1,$cut);
						} else {
							$msg .= " begin";
						}
					}
					utest_Assert::fail($msg, $pos);
					return;
				}
				$p = $p2 + strlen($s);
				unset($s,$p2);
			}
		}
		utest_Assert::isTrue(true, $msg, $pos);
	}
	static function pass($msg = null, $pos = null) {
		if($msg === null) {
			$msg = "pass expected";
		}
		utest_Assert::isTrue(true, $msg, $pos);
	}
	static function fail($msg = null, $pos = null) {
		if($msg === null) {
			$msg = "failure expected";
		}
		utest_Assert::isTrue(false, $msg, $pos);
	}
	static function warn($msg) {
		$tmp = utest_Assertation::Warning($msg);
		utest_Assert::$results->add($tmp);
	}
	static function createAsync($f = null, $timeout = null) { return call_user_func_array(self::$createAsync, array($f, $timeout)); }
	public static $createAsync = null;
	static function createEvent($f, $timeout = null) { return call_user_func_array(self::$createEvent, array($f, $timeout)); }
	public static $createEvent = null;
	static function typeToString($t) {
		try {
			$_t = Type::getClass($t);
			if($_t !== null) {
				$t = $_t;
			}
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{}
		}
		try {
			return Type::getClassName($t);
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e1 = $_ex_;
			{}
		}
		try {
			$_t1 = Type::getEnum($t);
			if($_t1 !== null) {
				$t = $_t1;
			}
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e2 = $_ex_;
			{}
		}
		try {
			return Type::getEnumName($t);
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e3 = $_ex_;
			{}
		}
		try {
			$tmp = Type::typeof($t);
			return Std::string($tmp);
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e4 = $_ex_;
			{}
		}
		try {
			return Std::string($t);
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e5 = $_ex_;
			{}
		}
		return "<unable to retrieve type name>";
	}
	function __toString() { return 'utest.Assert'; }
}
utest_Assert::$createAsync = array(new _hx_lambda(array(), "utest_Assert_4"), 'execute');
utest_Assert::$createEvent = array(new _hx_lambda(array(), "utest_Assert_5"), 'execute');
function utest_Assert_0(&$expected) {
	{
		return $expected;
	}
}
function utest_Assert_1(&$value) {
	{
		return $value;
	}
}
function utest_Assert_2(&$expected) {
	{
		return $expected;
	}
}
function utest_Assert_3(&$value) {
	{
		return $value;
	}
}
function utest_Assert_4($f, $timeout) {
	{
		return array(new _hx_lambda(array(), "utest_Assert_6"), 'execute');
	}
}
function utest_Assert_5($f, $timeout) {
	{
		return array(new _hx_lambda(array(), "utest_Assert_7"), 'execute');
	}
}
function utest_Assert_6() {
	{}
}
function utest_Assert_7($e) {
	{}
}
