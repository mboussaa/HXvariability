<?php

// Generated by Haxe 3.3.0
class haxe_macro_TypeTools {
	public function __construct(){}
	static function nullable($complexType) {
		$tmp = haxe_macro_TypeParam::TPType($complexType);
		return haxe_macro_ComplexType::TPath(_hx_anonymous(array("pack" => (new _hx_array(array())), "name" => "Null", "params" => (new _hx_array(array($tmp))))));
	}
	static function toField($cf) {
		$varAccessToString = array(new _hx_lambda(array(), "haxe_macro_TypeTools_0"), 'execute');
		$tmp = $cf->params->length === 0;
		if($tmp) {
			$tmp1 = null;
			if($cf->isPublic) {
				$tmp1 = (new _hx_array(array(haxe_macro_Access::$APublic)));
			} else {
				$tmp1 = (new _hx_array(array(haxe_macro_Access::$APrivate)));
			}
			$tmp2 = null;
			$_g = $cf->type;
			$_g1 = $cf->kind;
			$tmp3 = $_g1->index;
			switch($tmp3) {
			case 0:{
				$write = _hx_deref($_g1)->params[1];
				$tmp4 = call_user_func_array($varAccessToString, array(_hx_deref($_g1)->params[0], "get"));
				$tmp5 = call_user_func_array($varAccessToString, array($write, "set"));
				$tmp6 = haxe_macro_TypeTools::toComplexType($_g);
				$tmp2 = haxe_macro_FieldType::FProp($tmp4, $tmp5, $tmp6, null);
			}break;
			case 1:{
				$tmp7 = $_g->index === 4;
				if($tmp7) {
					$ret = _hx_deref($_g)->params[1];
					$args = _hx_deref($_g)->params[0];
					$_g2 = (new _hx_array(array()));
					{
						$_g11 = 0;
						while($_g11 < $args->length) {
							$a = $args[$_g11];
							++$_g11;
							$tmp8 = $a->opt;
							$tmp9 = haxe_macro_TypeTools::toComplexType($a->t);
							$_g2->push(_hx_anonymous(array("name" => $a->name, "opt" => $tmp8, "type" => $tmp9)));
							unset($tmp9,$tmp8,$a);
						}
					}
					$tmp10 = haxe_macro_TypeTools::toComplexType($ret);
					$tmp2 = haxe_macro_FieldType::FFun(_hx_anonymous(array("args" => $_g2, "ret" => $tmp10, "expr" => null)));
				} else {
					throw new HException("Invalid TAnonymous");
				}
			}break;
			}
			$tmp11 = $cf->meta->get();
			return _hx_anonymous(array("name" => $cf->name, "doc" => $cf->doc, "access" => $tmp1, "kind" => $tmp2, "pos" => $cf->pos, "meta" => $tmp11));
		} else {
			throw new HException("Invalid TAnonymous");
		}
	}
	static function toComplexType($type) {
		if($type === null) {
			return null;
		} else {
			$tmp = $type->index;
			switch($tmp) {
			case 0:{
				$_hx_tmp = _hx_deref($type)->params[0]->get();
				if($_hx_tmp === null) {
					return null;
				} else {
					return haxe_macro_TypeTools::toComplexType($_hx_tmp);
				}
			}break;
			case 1:{
				$_hx_tmp1 = _hx_deref($type)->params[0]->get();
				$tmp1 = haxe_macro_TypeTools::toTypePath($_hx_tmp1, _hx_deref($type)->params[1]);
				return haxe_macro_ComplexType::TPath($tmp1);
			}break;
			case 2:{
				$_hx_tmp2 = _hx_deref($type)->params[0]->get();
				$params = _hx_deref($type)->params[1];
				$tmp2 = $_hx_tmp2->kind->index === 1;
				if($tmp2) {
					return haxe_macro_ComplexType::TPath(_hx_anonymous(array("name" => $_hx_tmp2->name, "pack" => (new _hx_array(array())))));
				} else {
					$tmp3 = haxe_macro_TypeTools::toTypePath($_hx_tmp2, $params);
					return haxe_macro_ComplexType::TPath($tmp3);
				}
			}break;
			case 3:{
				$_hx_tmp3 = _hx_deref($type)->params[0]->get();
				$tmp4 = haxe_macro_TypeTools::toTypePath($_hx_tmp3, _hx_deref($type)->params[1]);
				return haxe_macro_ComplexType::TPath($tmp4);
			}break;
			case 4:{
				$ret = _hx_deref($type)->params[1];
				$args = _hx_deref($type)->params[0];
				$_g = (new _hx_array(array()));
				{
					$_g1 = 0;
					while($_g1 < $args->length) {
						$a = $args[$_g1];
						++$_g1;
						$tmp5 = null;
						$tmp6 = $a->opt;
						if($tmp6) {
							$tmp7 = haxe_macro_TypeTools::toComplexType($a->t);
							$tmp5 = haxe_macro_TypeTools::nullable($tmp7);
							unset($tmp7);
						} else {
							$tmp5 = haxe_macro_TypeTools::toComplexType($a->t);
						}
						$_g->push($tmp5);
						unset($tmp6,$tmp5,$a);
					}
				}
				$tmp8 = haxe_macro_TypeTools::toComplexType($ret);
				return haxe_macro_ComplexType::TFunction($_g, $tmp8);
			}break;
			case 5:{
				$_hx_tmp4 = _hx_deref($type)->params[0]->get();
				$fields = $_hx_tmp4->fields;
				$_g2 = (new _hx_array(array()));
				{
					$_g11 = 0;
					while($_g11 < $fields->length) {
						$cf = $fields[$_g11];
						++$_g11;
						$tmp9 = haxe_macro_TypeTools::toField($cf);
						$_g2->push($tmp9);
						unset($tmp9,$cf);
					}
				}
				return haxe_macro_ComplexType::TAnonymous($_g2);
			}break;
			case 6:{
				$t = _hx_deref($type)->params[0];
				if($t === null) {
					return haxe_macro_ComplexType::TPath(_hx_anonymous(array("pack" => (new _hx_array(array())), "name" => "Dynamic", "params" => (new _hx_array(array())))));
				} else {
					$ct = haxe_macro_TypeTools::toComplexType($t);
					$tmp10 = haxe_macro_TypeParam::TPType($ct);
					return haxe_macro_ComplexType::TPath(_hx_anonymous(array("pack" => (new _hx_array(array())), "name" => "Dynamic", "params" => (new _hx_array(array($tmp10))))));
				}
			}break;
			case 7:{
				$tmp11 = _hx_deref($type)->params[0]();
				return haxe_macro_TypeTools::toComplexType($tmp11);
			}break;
			case 8:{
				$_hx_tmp5 = _hx_deref($type)->params[0]->get();
				$tmp12 = haxe_macro_TypeTools::toTypePath($_hx_tmp5, _hx_deref($type)->params[1]);
				return haxe_macro_ComplexType::TPath($tmp12);
			}break;
			}
		}
	}
	static function toTypePath($baseType, $params) {
		$module = $baseType->module;
		$tmp = _hx_last_index_of($module, ".", null);
		$tmp1 = _hx_substring($module, $tmp + 1, null);
		$_g = (new _hx_array(array()));
		{
			$_g1 = 0;
			while($_g1 < $params->length) {
				$t = $params[$_g1];
				++$_g1;
				$tmp2 = haxe_macro_TypeTools::toComplexType($t);
				$tmp3 = haxe_macro_TypeParam::TPType($tmp2);
				$_g->push($tmp3);
				unset($tmp3,$tmp2,$t);
			}
		}
		return _hx_anonymous(array("pack" => $baseType->pack, "name" => $tmp1, "sub" => $baseType->name, "params" => $_g));
	}
	static function findField($c, $name, $isStatic = null) {
		if($isStatic === null) {
			$isStatic = false;
		}
		$tmp = null;
		if($isStatic) {
			$tmp = $c->statics;
		} else {
			$tmp = $c->fields;
		}
		$tmp1 = $tmp->get();
		$field = Lambda::find($tmp1, array(new _hx_lambda(array(&$name), "haxe_macro_TypeTools_1"), 'execute'));
		if($field !== null) {
			return $field;
		} else {
			if(_hx_field($c, "superClass") !== null) {
				$tmp2 = $c->superClass->t->get();
				return haxe_macro_TypeTools::findField($tmp2, $name, $isStatic);
			} else {
				return null;
			}
		}
	}
	function __toString() { return 'haxe.macro.TypeTools'; }
}
function haxe_macro_TypeTools_0($va, $getOrSet) {
	{
		switch($va->index) {
		case 0:{
			return "default";
		}break;
		case 1:{
			return "null";
		}break;
		case 2:{
			return "never";
		}break;
		case 3:{
			throw new HException("Invalid TAnonymous");
		}break;
		case 4:{
			return $getOrSet;
		}break;
		case 5:{
			return "default";
		}break;
		case 6:{
			return "default";
		}break;
		}
	}
}
function haxe_macro_TypeTools_1(&$name, $field1) {
	{
		return $field1->name === $name;
	}
}
