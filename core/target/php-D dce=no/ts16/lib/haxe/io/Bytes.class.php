<?php

// Generated by Haxe 3.3.0
class haxe_io_Bytes {
	public function __construct($length, $b) {
		if(!php_Boot::$skip_constructor) {
		$this->length = $length;
		$this->b = $b;
	}}
	public $length;
	public $b;
	public function get($pos) {
		return ord($this->b->s[$pos]);
	}
	public function set($pos, $v) {
		$this->b->s[$pos] = chr($v);
	}
	public function blit($pos, $src, $srcpos, $len) {
		$tmp = null;
		$tmp1 = null;
		$tmp2 = null;
		$tmp3 = null;
		if($pos >= 0) {
			$tmp3 = $srcpos < 0;
		} else {
			$tmp3 = true;
		}
		if(!$tmp3) {
			$tmp2 = $len < 0;
		} else {
			$tmp2 = true;
		}
		if(!$tmp2) {
			$tmp1 = $pos + $len > $this->length;
		} else {
			$tmp1 = true;
		}
		if(!$tmp1) {
			$tmp = $srcpos + $len > $src->length;
		} else {
			$tmp = true;
		}
		if($tmp) {
			throw new HException(haxe_io_Error::$OutsideBounds);
		}
		{
			$this1 = $this->b;
			{
				$val = substr($this1->s, 0, $pos) . substr($src->b->s, $srcpos, $len) . substr($this1->s, $pos+$len);
				$this1->s = $val;
			}
		}
	}
	public function fill($pos, $len, $value) {
		$_g1 = 0;
		$_g = $len;
		while($_g1 < $_g) {
			$i = $_g1++;
			{
				$pos1 = $pos++;
				$this->b->s[$pos1] = chr($value);
				unset($pos1);
			}
			unset($i);
		}
	}
	public function sub($pos, $len) {
		$tmp = null;
		$tmp1 = null;
		if($pos >= 0) {
			$tmp1 = $len < 0;
		} else {
			$tmp1 = true;
		}
		if(!$tmp1) {
			$tmp = $pos + $len > $this->length;
		} else {
			$tmp = true;
		}
		if($tmp) {
			throw new HException(haxe_io_Error::$OutsideBounds);
		}
		$s = substr($this->b->s, $pos, $len);
		$x = new php__BytesData_Wrapper($s);
		return new haxe_io_Bytes($len, $x);
	}
	public function compare($other) {
		return $this->b->s < $other->b->s ? -1 : ($this->b->s == $other->b->s ? 0 : 1);
	}
	public function getDouble($pos) {
		$tmp = ord($this->b->s[$pos]);
		$tmp1 = ord($this->b->s[$pos + 1]);
		$tmp2 = $tmp | $tmp1 << 8;
		$tmp3 = ord($this->b->s[$pos + 2]);
		$tmp4 = $tmp2 | $tmp3 << 16;
		$tmp5 = ord($this->b->s[$pos + 3]);
		$v = $tmp4 | $tmp5 << 24;
		$tmp6 = null;
		if(($v & -2147483648) !== 0) {
			$tmp6 = $v | -2147483648;
		} else {
			$tmp6 = $v;
		}
		$pos1 = $pos + 4;
		$tmp7 = ord($this->b->s[$pos1]);
		$tmp8 = ord($this->b->s[$pos1 + 1]);
		$tmp9 = $tmp7 | $tmp8 << 8;
		$tmp10 = ord($this->b->s[$pos1 + 2]);
		$tmp11 = $tmp9 | $tmp10 << 16;
		$tmp12 = ord($this->b->s[$pos1 + 3]);
		$v1 = $tmp11 | $tmp12 << 24;
		$tmp13 = null;
		if(($v1 & -2147483648) !== 0) {
			$tmp13 = $v1 | -2147483648;
		} else {
			$tmp13 = $v1;
		}
		return haxe_io_FPHelper::i64ToDouble($tmp6, $tmp13);
	}
	public function getFloat($pos) {
		$b = new haxe_io_BytesInput($this, $pos, 4);
		$tmp = $b->readInt32();
		return haxe_io_FPHelper::i32ToFloat($tmp);
	}
	public function setDouble($pos, $v) {
		$i = haxe_io_FPHelper::doubleToI64($v);
		{
			$v1 = $i->low;
			$this->b->s[$pos] = chr($v1);
			$this->b->s[$pos + 1] = chr($v1 >> 8);
			$this->b->s[$pos + 2] = chr($v1 >> 16);
			$this->b->s[$pos + 3] = chr(_hx_shift_right($v1, 24));
		}
		{
			$pos1 = $pos + 4;
			$v2 = $i->high;
			$this->b->s[$pos1] = chr($v2);
			$this->b->s[$pos1 + 1] = chr($v2 >> 8);
			$this->b->s[$pos1 + 2] = chr($v2 >> 16);
			$this->b->s[$pos1 + 3] = chr(_hx_shift_right($v2, 24));
		}
	}
	public function setFloat($pos, $v) {
		$v1 = haxe_io_FPHelper::floatToI32($v);
		$this->b->s[$pos] = chr($v1);
		$this->b->s[$pos + 1] = chr($v1 >> 8);
		$this->b->s[$pos + 2] = chr($v1 >> 16);
		$this->b->s[$pos + 3] = chr(_hx_shift_right($v1, 24));
	}
	public function getUInt16($pos) {
		$tmp = ord($this->b->s[$pos]);
		$tmp1 = ord($this->b->s[$pos + 1]);
		return $tmp | $tmp1 << 8;
	}
	public function setUInt16($pos, $v) {
		$this->b->s[$pos] = chr($v);
		$this->b->s[$pos + 1] = chr($v >> 8);
	}
	public function getInt32($pos) {
		$tmp = ord($this->b->s[$pos]);
		$tmp1 = ord($this->b->s[$pos + 1]);
		$tmp2 = $tmp | $tmp1 << 8;
		$tmp3 = ord($this->b->s[$pos + 2]);
		$tmp4 = $tmp2 | $tmp3 << 16;
		$tmp5 = ord($this->b->s[$pos + 3]);
		$v = $tmp4 | $tmp5 << 24;
		if(($v & -2147483648) !== 0) {
			return $v | -2147483648;
		} else {
			return $v;
		}
	}
	public function getInt64($pos) {
		$pos1 = $pos + 4;
		$tmp = ord($this->b->s[$pos1]);
		$tmp1 = ord($this->b->s[$pos1 + 1]);
		$tmp2 = $tmp | $tmp1 << 8;
		$tmp3 = ord($this->b->s[$pos1 + 2]);
		$tmp4 = $tmp2 | $tmp3 << 16;
		$tmp5 = ord($this->b->s[$pos1 + 3]);
		$v = $tmp4 | $tmp5 << 24;
		$high = null;
		if(($v & -2147483648) !== 0) {
			$high = $v | -2147483648;
		} else {
			$high = $v;
		}
		$tmp6 = ord($this->b->s[$pos]);
		$tmp7 = ord($this->b->s[$pos + 1]);
		$tmp8 = $tmp6 | $tmp7 << 8;
		$tmp9 = ord($this->b->s[$pos + 2]);
		$tmp10 = $tmp8 | $tmp9 << 16;
		$tmp11 = ord($this->b->s[$pos + 3]);
		$v1 = $tmp10 | $tmp11 << 24;
		$low = null;
		if(($v1 & -2147483648) !== 0) {
			$low = $v1 | -2147483648;
		} else {
			$low = $v1;
		}
		$x = new haxe__Int64____Int64($high, $low);
		return $x;
	}
	public function setInt32($pos, $v) {
		$this->b->s[$pos] = chr($v);
		$this->b->s[$pos + 1] = chr($v >> 8);
		$this->b->s[$pos + 2] = chr($v >> 16);
		$this->b->s[$pos + 3] = chr(_hx_shift_right($v, 24));
	}
	public function setInt64($pos, $v) {
		{
			$v1 = $v->low;
			$this->b->s[$pos] = chr($v1);
			$this->b->s[$pos + 1] = chr($v1 >> 8);
			$this->b->s[$pos + 2] = chr($v1 >> 16);
			$this->b->s[$pos + 3] = chr(_hx_shift_right($v1, 24));
		}
		{
			$pos1 = $pos + 4;
			$v2 = $v->high;
			$this->b->s[$pos1] = chr($v2);
			$this->b->s[$pos1 + 1] = chr($v2 >> 8);
			$this->b->s[$pos1 + 2] = chr($v2 >> 16);
			$this->b->s[$pos1 + 3] = chr(_hx_shift_right($v2, 24));
		}
	}
	public function getString($pos, $len) {
		$tmp = null;
		$tmp1 = null;
		if($pos >= 0) {
			$tmp1 = $len < 0;
		} else {
			$tmp1 = true;
		}
		if(!$tmp1) {
			$tmp = $pos + $len > $this->length;
		} else {
			$tmp = true;
		}
		if($tmp) {
			throw new HException(haxe_io_Error::$OutsideBounds);
		}
		return substr($this->b->s, $pos, $len);
	}
	public function readString($pos, $len) {
		return $this->getString($pos, $len);
	}
	public function toString() {
		return $this->b->s;
	}
	public function toHex() {
		$s = new StringBuf();
		$chars = (new _hx_array(array()));
		$str = "0123456789abcdef";
		{
			$_g1 = 0;
			$_g = strlen($str);
			while($_g1 < $_g) {
				$i = $_g1++;
				$tmp = _hx_char_code_at($str, $i);
				$chars->push($tmp);
				unset($tmp,$i);
			}
		}
		{
			$_g11 = 0;
			$_g2 = $this->length;
			while($_g11 < $_g2) {
				$i1 = $_g11++;
				$c = ord($this->b->s[$i1]);
				$s->b .= _hx_string_or_null(chr($chars[$c >> 4]));
				$s->b .= _hx_string_or_null(chr($chars[$c & 15]));
				unset($i1,$c);
			}
		}
		return $s->b;
	}
	public function getData() {
		return $this->b;
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function alloc($length) {
		$s = str_repeat(chr(0), $length);
		$x = new php__BytesData_Wrapper($s);
		return new haxe_io_Bytes($length, $x);
	}
	static function ofString($s) {
		$x = new php__BytesData_Wrapper($s);
		$x1 = $x;
		$tmp = strlen($x1->s);
		return new haxe_io_Bytes($tmp, $x1);
	}
	static function ofData($b) {
		$tmp = strlen($b->s);
		return new haxe_io_Bytes($tmp, $b);
	}
	static function fastGet($b, $pos) {
		return ord($b->s[$pos]);
	}
	function __toString() { return $this->toString(); }
}
