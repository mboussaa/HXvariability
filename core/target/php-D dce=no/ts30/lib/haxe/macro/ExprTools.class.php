<?php

// Generated by Haxe 3.3.0
class haxe_macro_ExprTools {
	public function __construct(){}
	static function toString($e) {
		return _hx_deref(new haxe_macro_Printer(null))->printExpr($e);
	}
	static function iter($e, $f) {
		$_g = $e->expr;
		$tmp = $_g->index;
		switch($tmp) {
		case 1:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			call_user_func_array($f, array(_hx_deref($_g)->params[1]));
		}break;
		case 2:{
			call_user_func_array($f, array(_hx_deref($_g)->params[1]));
			call_user_func_array($f, array(_hx_deref($_g)->params[2]));
		}break;
		case 3:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
		}break;
		case 4:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
		}break;
		case 5:{
			$fl = _hx_deref($_g)->params[0];
			{
				$_g1 = 0;
				while($_g1 < $fl->length) {
					$fd = $fl[$_g1];
					++$_g1;
					call_user_func_array($f, array($fd->expr));
					unset($fd);
				}
			}
		}break;
		case 6:{
			haxe_macro_ExprArrayTools::iter(_hx_deref($_g)->params[0], $f);
		}break;
		case 7:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			haxe_macro_ExprArrayTools::iter(_hx_deref($_g)->params[1], $f);
		}break;
		case 8:{
			haxe_macro_ExprArrayTools::iter(_hx_deref($_g)->params[1], $f);
		}break;
		case 9:{
			call_user_func_array($f, array(_hx_deref($_g)->params[2]));
		}break;
		case 10:{
			$vl = _hx_deref($_g)->params[0];
			{
				$_g2 = 0;
				while($_g2 < $vl->length) {
					$v = $vl[$_g2];
					++$_g2;
					{
						$e1 = $v->expr;
						if($e1 !== null) {
							call_user_func_array($f, array($e1));
						}
						unset($e1);
					}
					unset($v);
				}
			}
		}break;
		case 11:{
			$func = _hx_deref($_g)->params[1];
			{
				{
					$_g3 = 0;
					$_g11 = $func->args;
					while($_g3 < $_g11->length) {
						$arg = $_g11[$_g3];
						++$_g3;
						{
							$e2 = $arg->value;
							if($e2 !== null) {
								call_user_func_array($f, array($e2));
							}
							unset($e2);
						}
						unset($arg);
					}
				}
				{
					$e3 = $func->expr;
					if($e3 !== null) {
						call_user_func_array($f, array($e3));
					}
				}
			}
		}break;
		case 12:{
			haxe_macro_ExprArrayTools::iter(_hx_deref($_g)->params[0], $f);
		}break;
		case 13:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			call_user_func_array($f, array(_hx_deref($_g)->params[1]));
		}break;
		case 14:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			call_user_func_array($f, array(_hx_deref($_g)->params[1]));
		}break;
		case 15:{
			$e31 = _hx_deref($_g)->params[2];
			{
				call_user_func_array($f, array(_hx_deref($_g)->params[0]));
				call_user_func_array($f, array(_hx_deref($_g)->params[1]));
				if($e31 !== null) {
					call_user_func_array($f, array($e31));
				}
			}
		}break;
		case 16:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			call_user_func_array($f, array(_hx_deref($_g)->params[1]));
		}break;
		case 17:{
			$edef = _hx_deref($_g)->params[2];
			$cl = _hx_deref($_g)->params[1];
			{
				call_user_func_array($f, array(_hx_deref($_g)->params[0]));
				{
					$_g4 = 0;
					while($_g4 < $cl->length) {
						$c = $cl[$_g4];
						++$_g4;
						haxe_macro_ExprArrayTools::iter($c->values, $f);
						{
							$e4 = $c->guard;
							if($e4 !== null) {
								call_user_func_array($f, array($e4));
							}
							unset($e4);
						}
						{
							$e5 = $c->expr;
							if($e5 !== null) {
								call_user_func_array($f, array($e5));
							}
							unset($e5);
						}
						unset($c);
					}
				}
				$tmp1 = null;
				if($edef !== null) {
					$tmp1 = $edef->expr !== null;
				} else {
					$tmp1 = false;
				}
				if($tmp1) {
					call_user_func_array($f, array($edef));
				}
			}
		}break;
		case 18:{
			$cl1 = _hx_deref($_g)->params[1];
			{
				call_user_func_array($f, array(_hx_deref($_g)->params[0]));
				{
					$_g5 = 0;
					while($_g5 < $cl1->length) {
						$c1 = $cl1[$_g5];
						++$_g5;
						call_user_func_array($f, array($c1->expr));
						unset($c1);
					}
				}
			}
		}break;
		case 19:{
			$e6 = _hx_deref($_g)->params[0];
			if($e6 !== null) {
				call_user_func_array($f, array($e6));
			}
		}break;
		case 0:case 20:case 21:case 26:{}break;
		case 22:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
		}break;
		case 23:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
		}break;
		case 24:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
		}break;
		case 25:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
		}break;
		case 27:{
			$e32 = _hx_deref($_g)->params[2];
			{
				call_user_func_array($f, array(_hx_deref($_g)->params[0]));
				call_user_func_array($f, array(_hx_deref($_g)->params[1]));
				if($e32 !== null) {
					call_user_func_array($f, array($e32));
				}
			}
		}break;
		case 28:{
			call_user_func_array($f, array(_hx_deref($_g)->params[0]));
		}break;
		case 29:{
			call_user_func_array($f, array(_hx_deref($_g)->params[1]));
		}break;
		}
	}
	static function map($e, $f) {
		$_g = $e->expr;
		$tmp = null;
		$tmp1 = $_g->index;
		switch($tmp1) {
		case 0:{
			$tmp = $e->expr;
		}break;
		case 1:{
			$e2 = _hx_deref($_g)->params[1];
			$tmp2 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp3 = call_user_func_array($f, array($e2));
			$tmp = haxe_macro_ExprDef::EArray($tmp2, $tmp3);
		}break;
		case 2:{
			$e21 = _hx_deref($_g)->params[2];
			$e1 = _hx_deref($_g)->params[1];
			$op = _hx_deref($_g)->params[0];
			$tmp4 = call_user_func_array($f, array($e1));
			$tmp5 = call_user_func_array($f, array($e21));
			$tmp = haxe_macro_ExprDef::EBinop($op, $tmp4, $tmp5);
		}break;
		case 3:{
			$field = _hx_deref($_g)->params[1];
			$tmp6 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp = haxe_macro_ExprDef::EField($tmp6, $field);
		}break;
		case 4:{
			$tmp7 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp = haxe_macro_ExprDef::EParenthesis($tmp7);
		}break;
		case 5:{
			$fields = _hx_deref($_g)->params[0];
			$ret = (new _hx_array(array()));
			{
				$_g1 = 0;
				while($_g1 < $fields->length) {
					$field1 = $fields[$_g1];
					++$_g1;
					$tmp8 = call_user_func_array($f, array($field1->expr));
					$ret->push(_hx_anonymous(array("field" => $field1->field, "expr" => $tmp8)));
					unset($tmp8,$field1);
				}
			}
			$tmp = haxe_macro_ExprDef::EObjectDecl($ret);
		}break;
		case 6:{
			$tmp9 = haxe_macro_ExprArrayTools::map(_hx_deref($_g)->params[0], $f);
			$tmp = haxe_macro_ExprDef::EArrayDecl($tmp9);
		}break;
		case 7:{
			$params = _hx_deref($_g)->params[1];
			$tmp10 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp11 = haxe_macro_ExprArrayTools::map($params, $f);
			$tmp = haxe_macro_ExprDef::ECall($tmp10, $tmp11);
		}break;
		case 8:{
			$params1 = _hx_deref($_g)->params[1];
			$tp = _hx_deref($_g)->params[0];
			$tmp12 = haxe_macro_ExprArrayTools::map($params1, $f);
			$tmp = haxe_macro_ExprDef::ENew($tp, $tmp12);
		}break;
		case 9:{
			$e3 = _hx_deref($_g)->params[2];
			$postFix = _hx_deref($_g)->params[1];
			$op1 = _hx_deref($_g)->params[0];
			$tmp13 = call_user_func_array($f, array($e3));
			$tmp = haxe_macro_ExprDef::EUnop($op1, $postFix, $tmp13);
		}break;
		case 10:{
			$vars = _hx_deref($_g)->params[0];
			$ret1 = (new _hx_array(array()));
			{
				$_g2 = 0;
				while($_g2 < $vars->length) {
					$v = $vars[$_g2];
					++$_g2;
					$e4 = $v->expr;
					$tmp14 = null;
					if($e4 === null) {
						$tmp14 = null;
					} else {
						$tmp14 = call_user_func_array($f, array($e4));
					}
					$ret1->push(_hx_anonymous(array("name" => $v->name, "type" => $v->type, "expr" => $tmp14)));
					unset($v,$tmp14,$e4);
				}
			}
			$tmp = haxe_macro_ExprDef::EVars($ret1);
		}break;
		case 11:{
			$func = _hx_deref($_g)->params[1];
			$name = _hx_deref($_g)->params[0];
			$ret2 = (new _hx_array(array()));
			{
				$_g3 = 0;
				$_g11 = $func->args;
				while($_g3 < $_g11->length) {
					$arg = $_g11[$_g3];
					++$_g3;
					$tmp15 = $arg->opt;
					$e5 = $arg->value;
					$tmp16 = null;
					if($e5 === null) {
						$tmp16 = null;
					} else {
						$tmp16 = call_user_func_array($f, array($e5));
					}
					$ret2->push(_hx_anonymous(array("name" => $arg->name, "opt" => $tmp15, "type" => $arg->type, "value" => $tmp16)));
					unset($tmp16,$tmp15,$e5,$arg);
				}
			}
			$tmp17 = call_user_func_array($f, array($func->expr));
			$tmp = haxe_macro_ExprDef::EFunction($name, _hx_anonymous(array("args" => $ret2, "ret" => $func->ret, "params" => $func->params, "expr" => $tmp17)));
		}break;
		case 12:{
			$tmp18 = haxe_macro_ExprArrayTools::map(_hx_deref($_g)->params[0], $f);
			$tmp = haxe_macro_ExprDef::EBlock($tmp18);
		}break;
		case 13:{
			$expr = _hx_deref($_g)->params[1];
			$tmp19 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp20 = call_user_func_array($f, array($expr));
			$tmp = haxe_macro_ExprDef::EFor($tmp19, $tmp20);
		}break;
		case 14:{
			$e22 = _hx_deref($_g)->params[1];
			$tmp21 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp22 = call_user_func_array($f, array($e22));
			$tmp = haxe_macro_ExprDef::EIn($tmp21, $tmp22);
		}break;
		case 15:{
			$eelse = _hx_deref($_g)->params[2];
			$eif = _hx_deref($_g)->params[1];
			$tmp23 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp24 = call_user_func_array($f, array($eif));
			$tmp25 = null;
			if($eelse === null) {
				$tmp25 = null;
			} else {
				$tmp25 = call_user_func_array($f, array($eelse));
			}
			$tmp = haxe_macro_ExprDef::EIf($tmp23, $tmp24, $tmp25);
		}break;
		case 16:{
			$normalWhile = _hx_deref($_g)->params[2];
			$e6 = _hx_deref($_g)->params[1];
			$tmp26 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp27 = call_user_func_array($f, array($e6));
			$tmp = haxe_macro_ExprDef::EWhile($tmp26, $tmp27, $normalWhile);
		}break;
		case 17:{
			$edef = _hx_deref($_g)->params[2];
			$cases = _hx_deref($_g)->params[1];
			$e7 = _hx_deref($_g)->params[0];
			$ret3 = (new _hx_array(array()));
			{
				$_g4 = 0;
				while($_g4 < $cases->length) {
					$c = $cases[$_g4];
					++$_g4;
					$e8 = $c->expr;
					$tmp28 = null;
					if($e8 === null) {
						$tmp28 = null;
					} else {
						$tmp28 = call_user_func_array($f, array($e8));
					}
					$e9 = $c->guard;
					$tmp29 = null;
					if($e9 === null) {
						$tmp29 = null;
					} else {
						$tmp29 = call_user_func_array($f, array($e9));
					}
					$tmp30 = haxe_macro_ExprArrayTools::map($c->values, $f);
					$ret3->push(_hx_anonymous(array("expr" => $tmp28, "guard" => $tmp29, "values" => $tmp30)));
					unset($tmp30,$tmp29,$tmp28,$e9,$e8,$c);
				}
			}
			$tmp31 = call_user_func_array($f, array($e7));
			$tmp32 = null;
			$tmp33 = null;
			if($edef !== null) {
				$tmp33 = $edef->expr === null;
			} else {
				$tmp33 = true;
			}
			if($tmp33) {
				$tmp32 = $edef;
			} else {
				$tmp32 = call_user_func_array($f, array($edef));
			}
			$tmp = haxe_macro_ExprDef::ESwitch($tmp31, $ret3, $tmp32);
		}break;
		case 18:{
			$catches = _hx_deref($_g)->params[1];
			$e10 = _hx_deref($_g)->params[0];
			$ret4 = (new _hx_array(array()));
			{
				$_g5 = 0;
				while($_g5 < $catches->length) {
					$c1 = $catches[$_g5];
					++$_g5;
					$tmp34 = call_user_func_array($f, array($c1->expr));
					$ret4->push(_hx_anonymous(array("name" => $c1->name, "type" => $c1->type, "expr" => $tmp34)));
					unset($tmp34,$c1);
				}
			}
			$tmp35 = call_user_func_array($f, array($e10));
			$tmp = haxe_macro_ExprDef::ETry($tmp35, $ret4);
		}break;
		case 19:{
			$e11 = _hx_deref($_g)->params[0];
			$tmp36 = null;
			if($e11 === null) {
				$tmp36 = null;
			} else {
				$tmp36 = call_user_func_array($f, array($e11));
			}
			$tmp = haxe_macro_ExprDef::EReturn($tmp36);
		}break;
		case 20:case 21:case 26:{
			$tmp = $e->expr;
		}break;
		case 22:{
			$tmp37 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp = haxe_macro_ExprDef::EUntyped($tmp37);
		}break;
		case 23:{
			$tmp38 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp = haxe_macro_ExprDef::EThrow($tmp38);
		}break;
		case 24:{
			$t = _hx_deref($_g)->params[1];
			$tmp39 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp = haxe_macro_ExprDef::ECast($tmp39, $t);
		}break;
		case 25:{
			$isCall = _hx_deref($_g)->params[1];
			$tmp40 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp = haxe_macro_ExprDef::EDisplay($tmp40, $isCall);
		}break;
		case 27:{
			$eelse1 = _hx_deref($_g)->params[2];
			$eif1 = _hx_deref($_g)->params[1];
			$tmp41 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp42 = call_user_func_array($f, array($eif1));
			$tmp43 = call_user_func_array($f, array($eelse1));
			$tmp = haxe_macro_ExprDef::ETernary($tmp41, $tmp42, $tmp43);
		}break;
		case 28:{
			$t1 = _hx_deref($_g)->params[1];
			$tmp44 = call_user_func_array($f, array(_hx_deref($_g)->params[0]));
			$tmp = haxe_macro_ExprDef::ECheckType($tmp44, $t1);
		}break;
		case 29:{
			$e12 = _hx_deref($_g)->params[1];
			$m = _hx_deref($_g)->params[0];
			$tmp45 = call_user_func_array($f, array($e12));
			$tmp = haxe_macro_ExprDef::EMeta($m, $tmp45);
		}break;
		}
		return _hx_anonymous(array("pos" => $e->pos, "expr" => $tmp));
	}
	static function getValue($e) {
		$_g = $e->expr;
		$tmp = $_g->index;
		switch($tmp) {
		case 0:{
			$tmp1 = _hx_deref($_g)->params[0]->index;
			switch($tmp1) {
			case 0:{
				return Std::parseInt(_hx_deref(_hx_deref($_g)->params[0])->params[0]);
			}break;
			case 1:{
				return Std::parseFloat(_hx_deref(_hx_deref($_g)->params[0])->params[0]);
			}break;
			case 2:{
				return _hx_deref(_hx_deref($_g)->params[0])->params[0];
			}break;
			case 3:{
				switch(_hx_deref(_hx_deref($_g)->params[0])->params[0]) {
				case "false":{
					return false;
				}break;
				case "null":{
					return null;
				}break;
				case "true":{
					return true;
				}break;
				default:{
					$tmp2 = Std::string($e);
					throw new HException("Unsupported expression: " . _hx_string_or_null($tmp2));
				}break;
				}
			}break;
			default:{
				$tmp3 = Std::string($e);
				throw new HException("Unsupported expression: " . _hx_string_or_null($tmp3));
			}break;
			}
		}break;
		case 2:{
			$e2 = _hx_deref($_g)->params[2];
			$e1 = _hx_deref($_g)->params[1];
			$op = _hx_deref($_g)->params[0];
			$e11 = haxe_macro_ExprTools::getValue($e1);
			$e21 = haxe_macro_ExprTools::getValue($e2);
			$tmp4 = $op->index;
			switch($tmp4) {
			case 0:{
				return _hx_add($e11, $e21);
			}break;
			case 1:{
				return $e11 * $e21;
			}break;
			case 2:{
				return $e11 / $e21;
			}break;
			case 3:{
				return $e11 - $e21;
			}break;
			case 5:{
				return _hx_equal($e11, $e21);
			}break;
			case 6:{
				return !_hx_equal($e11, $e21);
			}break;
			case 7:{
				return $e11 > $e21;
			}break;
			case 8:{
				return $e11 >= $e21;
			}break;
			case 9:{
				return $e11 < $e21;
			}break;
			case 10:{
				return $e11 <= $e21;
			}break;
			case 11:{
				return $e11 & $e21;
			}break;
			case 12:{
				return $e11 | $e21;
			}break;
			case 13:{
				return $e11 ^ $e21;
			}break;
			case 14:{
				if($e11) {
					return $e21;
				} else {
					return false;
				}
			}break;
			case 15:{
				if(!$e11) {
					return $e21;
				} else {
					return true;
				}
			}break;
			case 16:{
				return $e11 << $e21;
			}break;
			case 17:{
				return $e11 >> $e21;
			}break;
			case 18:{
				return _hx_shift_right($e11, $e21);
			}break;
			case 19:{
				return _hx_mod($e11, $e21);
			}break;
			default:{
				$tmp5 = Std::string($e);
				throw new HException("Unsupported expression: " . _hx_string_or_null($tmp5));
			}break;
			}
		}break;
		case 4:{
			return haxe_macro_ExprTools::getValue(_hx_deref($_g)->params[0]);
		}break;
		case 5:{
			$fields = _hx_deref($_g)->params[0];
			$obj = _hx_anonymous(array());
			{
				$_g1 = 0;
				while($_g1 < $fields->length) {
					$field = $fields[$_g1];
					++$_g1;
					{
						$value = haxe_macro_ExprTools::getValue($field->expr);
						$obj->{$field->field} = $value;
						unset($value);
					}
					unset($field);
				}
			}
			return $obj;
		}break;
		case 6:{
			return _hx_deref($_g)->params[0]->map((isset(haxe_macro_ExprTools::$getValue) ? haxe_macro_ExprTools::$getValue: array("haxe_macro_ExprTools", "getValue")));
		}break;
		case 9:{
			if(_hx_deref($_g)->params[1] === false) {
				$e12 = _hx_deref($_g)->params[2];
				$op1 = _hx_deref($_g)->params[0];
				$e13 = haxe_macro_ExprTools::getValue($e12);
				$tmp6 = $op1->index;
				switch($tmp6) {
				case 2:{
					return !$e13;
				}break;
				case 3:{
					return -$e13;
				}break;
				case 4:{
					return ~$e13;
				}break;
				default:{
					$tmp7 = Std::string($e);
					throw new HException("Unsupported expression: " . _hx_string_or_null($tmp7));
				}break;
				}
			} else {
				$tmp8 = Std::string($e);
				throw new HException("Unsupported expression: " . _hx_string_or_null($tmp8));
			}
		}break;
		case 15:{
			$eelse = _hx_deref($_g)->params[2];
			$eif = _hx_deref($_g)->params[1];
			$econd = _hx_deref($_g)->params[0];
			if($eelse === null) {
				throw new HException("If statements only have a value if the else clause is defined");
			} else {
				$econd1 = haxe_macro_ExprTools::getValue($econd);
				if($econd1) {
					return haxe_macro_ExprTools::getValue($eif);
				} else {
					return haxe_macro_ExprTools::getValue($eelse);
				}
			}
		}break;
		case 22:{
			return haxe_macro_ExprTools::getValue(_hx_deref($_g)->params[0]);
		}break;
		case 27:{
			$eelse1 = _hx_deref($_g)->params[2];
			$eif1 = _hx_deref($_g)->params[1];
			$econd2 = _hx_deref($_g)->params[0];
			if($eelse1 === null) {
				throw new HException("If statements only have a value if the else clause is defined");
			} else {
				$econd3 = haxe_macro_ExprTools::getValue($econd2);
				if($econd3) {
					return haxe_macro_ExprTools::getValue($eif1);
				} else {
					return haxe_macro_ExprTools::getValue($eelse1);
				}
			}
		}break;
		case 29:{
			return haxe_macro_ExprTools::getValue(_hx_deref($_g)->params[1]);
		}break;
		default:{
			$tmp9 = Std::string($e);
			throw new HException("Unsupported expression: " . _hx_string_or_null($tmp9));
		}break;
		}
	}
	static function opt($e, $f) {
		if($e === null) {
			return null;
		} else {
			return call_user_func_array($f, array($e));
		}
	}
	static function opt2($e, $f) {
		if($e !== null) {
			call_user_func_array($f, array($e));
		}
	}
	function __toString() { return 'haxe.macro.ExprTools'; }
}
