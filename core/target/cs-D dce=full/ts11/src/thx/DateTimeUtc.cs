// Generated by Haxe 3.3.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace thx._DateTimeUtc {
	public sealed class DateTimeUtc_Impl_ {
		
		static DateTimeUtc_Impl_() {
			unchecked {
				global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerMillisecond = 10000;
				global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerMillisecondI64 = ((long) (global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerMillisecond) );
				global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerSecondI64 = ((long) (( ((long) (global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerMillisecondI64) ) * ((long) (1000) ) )) );
				global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerMinuteI64 = ((long) (( ((long) (global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerSecondI64) ) * ((long) (60) ) )) );
				global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerHourI64 = ((long) (( ((long) (global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerMinuteI64) ) * ((long) (60) ) )) );
				global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerDayI64 = ((long) (( ((long) (global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerHourI64) ) * ((long) (24) ) )) );
				global::thx._DateTimeUtc.DateTimeUtc_Impl_.daysToMonth365 = new global::Array<int>(new int[]{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365});
				global::thx._DateTimeUtc.DateTimeUtc_Impl_.daysToMonth366 = new global::Array<int>(new int[]{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366});
			}
		}
		
		
		public static int ticksPerMillisecond;
		
		public static long ticksPerMillisecondI64;
		
		public static long ticksPerSecondI64;
		
		public static long ticksPerMinuteI64;
		
		public static long ticksPerHourI64;
		
		public static long ticksPerDayI64;
		
		public static global::Array<int> daysToMonth365;
		
		public static global::Array<int> daysToMonth366;
		
		public static long fromInt64(long ticks) {
			return ((long) (ticks) );
		}
		
		
		public static long create(int year, int month, int day, global::haxe.lang.Null<int> hour, global::haxe.lang.Null<int> minute, global::haxe.lang.Null<int> second, global::haxe.lang.Null<int> millisecond) {
			unchecked {
				global::haxe.lang.Null<int> __temp_millisecond37 = ( ( ! (millisecond.hasValue) ) ? (new global::haxe.lang.Null<int>(0, true)) : (millisecond) );
				global::haxe.lang.Null<int> __temp_second36 = ( ( ! (second.hasValue) ) ? (new global::haxe.lang.Null<int>(0, true)) : (second) );
				global::haxe.lang.Null<int> __temp_minute35 = ( ( ! (minute.hasValue) ) ? (new global::haxe.lang.Null<int>(0, true)) : (minute) );
				global::haxe.lang.Null<int> __temp_hour34 = ( ( ! (hour.hasValue) ) ? (new global::haxe.lang.Null<int>(0, true)) : (hour) );
				__temp_second36 = new global::haxe.lang.Null<int>(( (__temp_second36).@value + ((int) (global::System.Math.Floor(((double) (( ((double) ((__temp_millisecond37).@value) ) / 1000 )) ))) ) ), true);
				__temp_millisecond37 = new global::haxe.lang.Null<int>(((int) (( (__temp_millisecond37).@value % (new global::haxe.lang.Null<int>(1000, true)).@value )) ), true);
				if (( (__temp_millisecond37).@value < 0 )) {
					__temp_millisecond37 = new global::haxe.lang.Null<int>(( (__temp_millisecond37).@value + 1000 ), true);
				}
				
				long ticks = ((long) (( ((long) (( ((long) (global::thx._DateTimeUtc.DateTimeUtc_Impl_.dateToTicks(year, month, day)) ) + ((long) (global::thx._Time.Time_Impl_.timeToTicks((__temp_hour34).@value, (__temp_minute35).@value, (__temp_second36).@value)) ) )) ) + ((long) (( ((long) ((__temp_millisecond37).@value) ) * ((long) (global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerMillisecondI64) ) )) ) )) );
				return ((long) (ticks) );
			}
		}
		
		
		public static bool isLeapYear(int year) {
			unchecked {
				if (( ( year % 4 ) == 0 )) {
					if (( ( year % 100 ) == 0 )) {
						return ( ( year % 400 ) == 0 );
					}
					else {
						return true;
					}
					
				}
				else {
					return false;
				}
				
			}
		}
		
		
		public static long dateToTicks(int year, int month, int day) {
			unchecked {
				int[] month1 = new int[]{month};
				int[] year1 = new int[]{year};
				global::haxe.lang.Function fixMonthYear = new global::thx._DateTimeUtc.DateTimeUtc_Impl__dateToTicks_119__Fun(year1, month1);
				while (( day < 0 )) {
					month1[0]--;
					fixMonthYear.__hx_invoke0_o();
					day += global::thx._DateTimeUtc.DateTimeUtc_Impl_.daysInMonth(year1[0], month1[0]);
				}
				
				fixMonthYear.__hx_invoke0_o();
				int days = default(int);
				while (true) {
					days = global::thx._DateTimeUtc.DateTimeUtc_Impl_.daysInMonth(year1[0], month1[0]);
					if ( ! ((( day > days ))) ) {
						break;
					}
					
					month1[0]++;
					fixMonthYear.__hx_invoke0_o();
					day -= days;
				}
				
				if (( day == 0 )) {
					month1[0] -= 1;
					fixMonthYear.__hx_invoke0_o();
					day = global::thx._DateTimeUtc.DateTimeUtc_Impl_.daysInMonth(year1[0], month1[0]);
				}
				
				fixMonthYear.__hx_invoke0_o();
				return global::thx._DateTimeUtc.DateTimeUtc_Impl_.rawDateToTicks(year1[0], month1[0], day);
			}
		}
		
		
		public static long rawDateToTicks(int year, int month, int day) {
			unchecked {
				global::Array<int> days = ( (global::thx._DateTimeUtc.DateTimeUtc_Impl_.isLeapYear(year)) ? (global::thx._DateTimeUtc.DateTimeUtc_Impl_.daysToMonth366) : (global::thx._DateTimeUtc.DateTimeUtc_Impl_.daysToMonth365) );
				if (( ( day >= 1 ) && ( day <= ( days[month] - days[( month - 1 )] ) ) )) {
					int y = ( year - 1 );
					return ((long) (( ((long) (( ( ( ( ( ( ( y * 365 ) + ((int) (( y / 4 )) ) ) - ((int) (( y / 100 )) ) ) + ((int) (( y / 400 )) ) ) + days[( month - 1 )] ) + day ) - 1 )) ) * ((long) (global::thx._DateTimeUtc.DateTimeUtc_Impl_.ticksPerDayI64) ) )) );
				}
				
				throw global::haxe.lang.HaxeException.wrap(new global::thx.Error(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("bad year/month/day ", global::haxe.lang.Runtime.toString(year)), "/"), global::haxe.lang.Runtime.toString(month)), "/"), global::haxe.lang.Runtime.toString(day)), null, new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"rawDateToTicks", "thx._DateTimeUtc.DateTimeUtc_Impl_", "DateTimeUtc.hx"}, new int[]{1981972957}, new double[]{((double) (167) )})));
			}
		}
		
		
		public static int daysInMonth(int year, int month) {
			unchecked {
				global::Array<int> days = ( (global::thx._DateTimeUtc.DateTimeUtc_Impl_.isLeapYear(year)) ? (global::thx._DateTimeUtc.DateTimeUtc_Impl_.daysToMonth366) : (global::thx._DateTimeUtc.DateTimeUtc_Impl_.daysToMonth365) );
				return ( days[month] - days[( month - 1 )] );
			}
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace thx._DateTimeUtc {
	public class DateTimeUtc_Impl__dateToTicks_119__Fun : global::haxe.lang.Function {
		
		public DateTimeUtc_Impl__dateToTicks_119__Fun(int[] year1, int[] month1) : base(0, 0) {
			this.year1 = year1;
			this.month1 = month1;
		}
		
		
		public override object __hx_invoke0_o() {
			unchecked {
				if (( this.month1[0] == 0 )) {
					this.year1[0]--;
					this.month1[0] = 12;
				}
				else if (( this.month1[0] < 0 )) {
					this.month1[0] =  - (this.month1[0]) ;
					int years = ((int) (global::System.Math.Ceiling(((double) (( ((double) (this.month1[0]) ) / 12 )) ))) );
					this.year1[0] -= years;
					this.month1[0] = ( ( years * 12 ) - this.month1[0] );
				}
				else if (( this.month1[0] > 12 )) {
					int years1 = ((int) (global::System.Math.Floor(((double) (( ((double) (this.month1[0]) ) / 12 )) ))) );
					this.year1[0] += years1;
					this.month1[0] = ( this.month1[0] - ( years1 * 12 ) );
				}
				
				return null;
			}
		}
		
		
		public int[] year1;
		
		public int[] month1;
		
	}
}


