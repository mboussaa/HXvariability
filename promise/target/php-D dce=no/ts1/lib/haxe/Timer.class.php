<?php

// Generated by Haxe 3.3.0
class haxe_Timer {
	public function __construct($time_ms) {
		if(!isset($this->run)) $this->run = array(new _hx_lambda(array(&$this), "haxe_Timer_0"), 'execute');
		if(!php_Boot::$skip_constructor) {
		$_gthis = $this;
		$dt = $time_ms / 1000;
		$this->event = haxe_MainLoop::add(array(new _hx_lambda(array(&$_gthis, &$dt), "haxe_Timer_1"), 'execute'), null);
		$this->event->delay($dt);
	}}
	public $event;
	public function stop() {
		if($this->event !== null) {
			$this->event->stop();
			$this->event = null;
		}
	}
	public function run() { return call_user_func($this->run); }
	public $run = null;
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function delay($f, $time_ms) {
		$t = new haxe_Timer($time_ms);
		$t->run = array(new _hx_lambda(array(&$f, &$t), "haxe_Timer_2"), 'execute');
		return $t;
	}
	static function measure($f, $pos = null) {
		$t0 = haxe_Timer::stamp();
		$r = call_user_func($f);
		$tmp = haxe_Timer::stamp();
		haxe_Log::trace(_hx_string_rec($tmp - $t0, "") . "s", $pos);
		return $r;
	}
	static function stamp() {
		return Sys::time();
	}
	function __toString() { return 'haxe.Timer'; }
}
function haxe_Timer_0(&$__hx__this) {
	{}
}
function haxe_Timer_1(&$_gthis, &$dt) {
	{
		$_gthis->event->nextRun += $dt;
		$_gthis->run();
	}
}
function haxe_Timer_2(&$f, &$t) {
	{
		$t->stop();
		call_user_func($f);
	}
}
